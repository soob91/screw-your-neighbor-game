<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screw Your Neighbor - Personal Table</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 10px 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 15px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        .game-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            opacity: 0.9;
            flex-wrap: wrap;
        }

        /* Personal Table Layout */
        .personal-table {
            margin-bottom: 15px;
        }

        .focus-grid {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr;
            grid-template-rows: auto auto;
            gap: 8px;
            margin-bottom: 15px;
        }

        .focus-slot {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px;
            min-height: 140px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .focus-slot.current-turn {
            border-color: #00FF00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
            }
        }

        .focus-slot.custom {
            border-color: #FFD700;
            grid-row: 2;
        }

        .focus-slot.custom:first-of-type {
            grid-column: 1;
        }

        .focus-slot.custom:last-of-type {
            grid-column: 3;
        }

        .focus-slot.dealer {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }

        .focus-slot.empty {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
        }

        .focus-slot.empty .add-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        /* Card + Video Side-by-Side Layout */
        .player-content {
            display: flex;
            gap: 8px;
            align-items: stretch;
            height: 100%;
        }

        .card-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .video-section {
            width: 80px;
            flex-shrink: 0;
        }

        .video-container {
            width: 100%;
            height: 60px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #222;
        }

        .video-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #555);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.7rem;
        }

        /* Enhanced Video Controls */
        .video-controls {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            gap: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .focus-slot:hover .video-controls {
            opacity: 1;
        }

        .video-control-btn {
            padding: 1px 2px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 2px;
            font-size: 0.5rem;
            cursor: pointer;
            transition: background 0.3s ease;
            flex: 1;
        }

        .video-control-btn:hover {
            background: rgba(0, 0, 0, 1);
        }

        .video-control-btn.active {
            background: #4caf50;
        }

        .video-control-btn.muted {
            background: #f44336;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }

        .player-name {
            font-weight: bold;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-lives {
            background: rgba(255, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        /* Playing Card Design - Proper Card Proportions */
        .card-display {
            width: 80px;
            height: 110px;
            background: linear-gradient(145deg, #ffffff, #f8f8f8);
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            margin: 8px auto;
            transition: all 0.3s ease;
            font-family: 'Times New Roman', serif;
            font-size: 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .card-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .card-display.face-down {
            background: linear-gradient(145deg, #1a237e, #303f9f);
            color: white;
            font-size: 1.5rem;
        }

        .card-display.face-down:hover {
            transform: scale(1.05);
        }

        .card-display.red {
            color: #d32f2f;
            background: linear-gradient(145deg, #ffffff, #fafafa);
        }

        .card-display.black {
            color: #212121;
            background: linear-gradient(145deg, #ffffff, #fafafa);
        }

        .card-display.revealed {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transform: scale(1.02);
        }

        /* Nudge Animations */
        .nudge-shake {
            animation: shake 0.5s ease-in-out infinite;
        }

        .nudge-pulse {
            animation: pulse-glow 1s ease-in-out;
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px) rotate(-1deg); }
            75% { transform: translateX(3px) rotate(1deg); }
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
                border-color: rgba(255, 215, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.9);
                border-color: rgba(255, 215, 0, 1);
            }
        }

        /* Gesture Feedback */
        .card-display.gesture-active {
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        }

        .card-display.king-auto {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
            animation: king-reveal 2s ease-out;
        }

        @keyframes king-reveal {
            0% {
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
            }
            50% {
                transform: scale(1.1) rotate(5deg);
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }
            100% {
                transform: scale(1.02) rotate(0deg);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            }
        }

        /* Card content styling */
        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card-value {
            font-size: 1.1rem;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 2px;
        }

        .card-suit {
            font-size: 1.3rem;
            line-height: 1;
        }

        .action-button {
            width: 100%;
            padding: 6px 8px;
            background: #00a8ff;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 5px;
        }

        .action-button:hover {
            background: #0097e6;
            transform: translateY(-1px);
        }

        .action-button:disabled {
            background: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        .action-button.trade {
            background: #e74c3c;
        }

        .action-button.trade:hover {
            background: #c0392b;
        }

        .remove-button {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.8);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            display: none;
        }

        .focus-slot.custom .remove-button {
            display: block;
        }

        /* Available Players Bar */
        .available-players {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .available-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
            opacity: 0.8;
        }

        .players-scroll {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            padding: 5px 0;
            scrollbar-width: thin;
        }

        .players-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .players-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .players-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .available-player {
            min-width: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            position: relative;
            flex-shrink: 0;
        }

        .available-player:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .available-player.focused {
            border-color: #00FF00;
            background: rgba(0, 255, 0, 0.1);
        }

        .available-player.current-turn {
            border-color: #00FF00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.4);
        }

        .available-player.dealer {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .available-player.tradeable {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            animation: tradeGlow 2s infinite;
        }

        @keyframes tradeGlow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(231, 76, 60, 0.3);
            }
            50% {
                box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
            }
        }

        .available-player .check-mark {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #00FF00;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .available-player .player-name {
            font-size: 0.7rem;
            margin-bottom: 3px;
            font-weight: bold;
        }

        /* Mini Cards - Proper Proportions */
        .available-player .mini-card {
            width: 30px;
            height: 42px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid #ddd;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 0.6rem;
            font-weight: bold;
            margin: 2px auto;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .available-player .mini-card.face-down {
            background: linear-gradient(145deg, #1a237e, #303f9f);
            color: white;
            font-size: 0.7rem;
        }

        .available-player .mini-card.red {
            color: #d32f2f;
        }

        .available-player .mini-card.black {
            color: #212121;
        }

        .available-player .mini-lives {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Game Controls */
        .game-controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .control-button {
            padding: 12px 8px;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }

        .control-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .control-button:disabled {
            background: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        .control-button.danger {
            background: #e74c3c;
        }

        .control-button.warning {
            background: #f39c12;
        }

        .control-button.primary {
            background: #3498db;
        }

        /* Chat and Game Log */
        .bottom-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .chat-section,
        .game-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            display: flex;
            flex-direction: column;
        }

        .section-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
            opacity: 0.8;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            font-size: 0.7rem;
            margin-bottom: 8px;
            scrollbar-width: thin;
        }

        .messages::-webkit-scrollbar {
            width: 4px;
        }

        .messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .chat-input {
            display: flex;
            gap: 5px;
        }

        .chat-input input {
            flex: 1;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8rem;
        }

        .chat-input input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .chat-input button {
            padding: 6px 12px;
            background: #3498db;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Menu Screens */
        .menu-screen {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            margin: 0 auto;
        }

        .menu-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #3498db;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .input-group {
            margin: 15px 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Loading and Status */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.1rem;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 480px) {
            .focus-grid {
                grid-template-columns: 1fr 0.7fr 1fr;
                gap: 6px;
            }

            .focus-slot {
                min-height: 120px;
                padding: 6px;
            }

            .video-container {
                height: 50px;
            }

            .video-section {
                width: 60px;
            }

            .game-controls {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }

            .control-button {
                padding: 8px 4px;
                font-size: 0.7rem;
            }

            .bottom-section {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .game-status {
                font-size: 0.8rem;
            }

            .card-display {
                width: 60px;
                height: 85px;
                font-size: 0.8rem;
            }

            .available-player .mini-card {
                width: 25px;
                height: 35px;
                font-size: 0.5rem;
            }
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success {
            border-left: 4px solid #27ae60;
        }

        .toast.error {
            border-left: 4px solid #e74c3c;
        }

        .toast.warning {
            border-left: 4px solid #f39c12;
        }

        /* Lives as Dots Display */
        .player-lives-dots {
            display: flex;
            gap: 2px;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 10px;
            flex-shrink: 0;
        }

        .life-dot {
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .life-dot.lost {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mini-lives-dots {
            display: flex;
            gap: 1px;
            justify-content: center;
            margin-top: 2px;
        }

        .mini-life-dot {
            width: 4px;
            height: 4px;
            background: #e74c3c;
            border-radius: 50%;
        }

        .mini-life-dot.lost {
            background: rgba(255, 255, 255, 0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Eliminated Player Styles */
        .focus-slot.eliminated {
            opacity: 0.5;
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .focus-slot.eliminated .card-display {
            opacity: 0.4;
            background: linear-gradient(145deg, #444, #666) !important;
            color: rgba(255, 255, 255, 0.6) !important;
            transform: scale(0.9);
        }

        .focus-slot.eliminated .player-name {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .eliminated-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
        }

        .available-player.eliminated {
            opacity: 0.4;
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .available-player.eliminated .player-name {
            text-decoration: line-through;
            opacity: 0.6;
        }

        /* Jack "Screw You!" animations */
        .jack-block-reveal {
            border: 4px solid #e74c3c !important;
            box-shadow: 0 0 30px rgba(231, 76, 60, 1) !important;
            animation: jackBlockPulse 2s ease-out;
            transform: scale(1.1) !important;
        }

        @keyframes jackRevealBurst {
            0% {
                opacity: 0;
                transform: scale(0.3);
                background: rgba(255, 0, 0, 0);
            }
            50% {
                opacity: 1;
                transform: scale(1.1);
                background: rgba(255, 0, 0, 0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                background: rgba(255, 0, 0, 0.8);
            }
        }

        @keyframes jackBounceIn {
            0% {
                transform: scale(0.3) rotate(-10deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotate(5deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes jackBlockPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
                transform: scale(1.05);
            }
            25% {
                box-shadow: 0 0 40px rgba(231, 76, 60, 1);
                transform: scale(1.15) rotate(2deg);
            }
            50% {
                box-shadow: 0 0 50px rgba(231, 76, 60, 1);
                transform: scale(1.2) rotate(-2deg);
            }
            75% {
                box-shadow: 0 0 40px rgba(231, 76, 60, 1);
                transform: scale(1.15) rotate(1deg);
            }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes jackFlyOut {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }
            25% {
                transform: scale(1.5) rotate(360deg);
                opacity: 1;
                box-shadow: 0 0 30px rgba(231, 76, 60, 0.6);
            }
            50% {
                transform: scale(2) rotate(720deg);
                opacity: 1;
                box-shadow: 0 0 50px rgba(231, 76, 60, 0.8);
                left: 50%;
                top: 50%;
                margin-left: -40px;
                margin-top: -55px;
            }
            100% {
                transform: scale(3) rotate(1080deg);
                opacity: 1;
                box-shadow: 0 0 80px rgba(231, 76, 60, 1);
                left: 50%;
                top: 50%;
                margin-left: -40px;
                margin-top: -55px;
            }
        }

        @keyframes textBurstIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes jackShootOff {
            0% {
                transform: scale(2.5) rotate(1440deg) translateX(calc(50vw - 50%)) translateY(calc(50vh - 50%));
                opacity: 1;
            }
            100% {
                transform: scale(0.5) rotate(1800deg) translateX(150vw) translateY(-50vh);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <!-- Main Menu -->
    <div id="main-menu" class="menu-screen">
        <h1>🎴 Screw Your Neighbor</h1>
        <p>Personal Table Experience</p>

        <button class="menu-button" onclick="showQuickMatch()">⚡ Quick Match</button>
        <button class="menu-button" onclick="showCreateGame()">🎮 Create Private Game</button>
        <button class="menu-button" onclick="showJoinGame()">🎯 Join Game</button>

        <div class="input-group">
            <label for="playerName">Your Name:</label>
            <input type="text" id="playerName" placeholder="Enter your name" value="Player">
        </div>
    </div>

    <!-- Quick Match Screen -->
    <div id="quick-match" class="menu-screen hidden">
        <h2>⚡ Quick Match</h2>
        <p>Finding available games...</p>
        <div class="loading">
            <div class="spinner"></div>
            <span>Searching for players...</span>
        </div>
        <button class="menu-button" onclick="showMainMenu()">← Back</button>
    </div>

    <!-- Create Game Screen -->
    <div id="create-game" class="menu-screen hidden">
        <h2>🎮 Create Private Game</h2>

        <div class="input-group">
            <label for="startingLives">Starting Lives:</label>
            <select id="startingLives">
                <option value="3">3 Lives</option>
                <option value="5">5 Lives</option>
                <option value="7">7 Lives</option>
            </select>
        </div>

        <div class="input-group">
            <label for="deckCount">Number of Decks:</label>
            <select id="deckCount">
                <option value="1">1 Deck</option>
                <option value="2">2 Decks</option>
            </select>
        </div>

        <button class="menu-button" onclick="createPrivateGame()">Create Game</button>
        <button class="menu-button" onclick="showMainMenu()">← Back</button>
    </div>

    <!-- Join Game Screen -->
    <div id="join-game" class="menu-screen hidden">
        <h2>🎯 Join Game</h2>

        <div class="input-group">
            <label for="gameCode">Game Code:</label>
            <input type="text" id="gameCode" placeholder="Enter game code" style="text-transform: uppercase;">
        </div>

        <button class="menu-button" onclick="joinGame()">Join Game</button>
        <button class="menu-button" onclick="showMainMenu()">← Back</button>
    </div>

    <!-- Game Content -->
    <div id="gameContent" class="container hidden">
        <!-- Header -->
        <div class="header">
            <h1>🎴 Screw Your Neighbor</h1>
            <div class="game-status">
                <span id="gameCodeDisplay">Game: <strong>LOADING</strong></span>
                <span id="playerCount">Players: <strong>0/0</strong></span>
                <span id="connectionStatus">🔴 Connecting...</span>
            </div>
        </div>

        <!-- Personal Table -->
        <div class="personal-table">
            <div class="focus-grid" id="focusGrid">
                <!-- Focus slots will be populated by JavaScript -->
            </div>
        </div>

        <!-- Available Players Bar -->
        <div class="available-players">
            <div class="available-title">Available Players - Tap to Focus</div>
            <div class="players-scroll" id="playersScroll">
                <!-- Available players will be populated by JavaScript -->
            </div>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button class="control-button" id="flipCardBtn" onclick="handleFlipClick()" disabled>
                🎴 Flip Card
            </button>
            <button class="control-button" id="keepCardBtn" onclick="handleKeepClick()" disabled>
                ✋ Keep Card
            </button>
            <button class="control-button" id="tradeCardBtn" onclick="handleTradeClick()" disabled>
                🔄 Trade Card
            </button>
            <button class="control-button warning" id="endRoundBtn" onclick="endRound()" disabled>
                ⏰ End Round
            </button>
            <button class="control-button danger" onclick="clearStuckCard()" style="background: purple;">
                🧹 Clear Card
            </button>
            <button class="control-button danger" onclick="leaveGame()">
                🚪 Leave
            </button>
        </div>

        <!-- Start Game Button (for host) -->
        <div id="hostControls" class="game-controls hidden">
            <button class="control-button primary" id="startGameBtn" onclick="startGame()">
                🚀 Start Game
            </button>
        </div>

        <!-- Bottom Section -->
        <div class="bottom-section">
            <div class="chat-section">
                <div class="section-title">💬 Chat</div>
                <div class="messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
                    <button onclick="sendChatMessage()">Send</button>
                </div>
            </div>
            <div class="game-log">
                <div class="section-title">📋 Game Log</div>
                <div class="messages" id="gameMessages"></div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.19.1.js"></script>

    <script>
        // Global variables
        let socket = null;
        let currentGame = null;
        let playerId = null;
        let playerName = '';

        // Personal Table state
        let focusedPlayers = null;

        // Video state
        let isVideoJoined = false;
        let agoraClient = null;
        let localVideoTrack = null;
        let localAudioTrack = null;
        let remoteUsers = {};
        let videoStates = {};

        // Production optimizations
        let updateTimeout = null;
        let lastGameState = null;

        // Gesture and King Logic State
        let playerCardLooks = {}; // Track who has looked at their card
        let gestureState = {
            startX: 0,
            startY: 0,
            startTime: 0,
            isTracking: false,
            element: null,
            lastTap: 0
        };

        // Nudge system
        let nudgeTimeouts = {};
        let nudgeIntervals = {};

        // Auto-continue system
        let autoContinueTimer = null;
        let countdownSeconds = 15;
        let playersReadyForNext = new Set();

        // Utility functions
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage);
            addGameMessage(message);
        }

        function addGameMessage(message) {
            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages) {
                const messageDiv = document.createElement('div');
                messageDiv.textContent = message;
                gameMessages.appendChild(messageDiv);
                gameMessages.scrollTop = gameMessages.scrollHeight;

                while (gameMessages.children.length > 100) {
                    gameMessages.removeChild(gameMessages.firstChild);
                }
            }
        }

        function addChatMessage(playerName, message) {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = `<strong>${playerName}:</strong> ${message}`;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                while (chatMessages.children.length > 50) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }

        function createLivesDisplay(player, isMini = false) {
            const maxLives = currentGame?.settings?.startingLives || 3;
            const currentLives = player.lives || 0;

            if (isMini) {
                const miniLivesContainer = document.createElement('div');
                miniLivesContainer.className = 'mini-lives-dots';

                for (let i = 0; i < maxLives; i++) {
                    const dot = document.createElement('div');
                    dot.className = i < currentLives ? 'mini-life-dot' : 'mini-life-dot lost';
                    miniLivesContainer.appendChild(dot);
                }

                return miniLivesContainer;
            } else {
                const livesContainer = document.createElement('div');
                livesContainer.className = 'player-lives-dots';

                for (let i = 0; i < maxLives; i++) {
                    const dot = document.createElement('div');
                    dot.className = i < currentLives ? 'life-dot' : 'life-dot lost';
                    livesContainer.appendChild(dot);
                }

                return livesContainer;
            }
        }

        // Initialize clean focus state
        function initializeFocusState() {
            focusedPlayers = {
                leftNeighbor: null,
                currentTurn: null,
                rightNeighbor: null,
                custom1: null,
                custom2: null
            };
        }

        // Enhanced Gesture Detection System
        function initializeGestureHandlers(cardElement, targetPlayerId) {
            if (!cardElement) {
                log(`❌ No card element to initialize gestures for player ${targetPlayerId}`);
                return;
            }

            log(`🎯 Initializing gesture handlers for player ${targetPlayerId}`);

            // Touch events for mobile
            cardElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            cardElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            cardElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Mouse events for desktop
            cardElement.addEventListener('mousedown', handleMouseStart);
            cardElement.addEventListener('mousemove', handleMouseMove);
            cardElement.addEventListener('mouseup', handleMouseEnd);

            // Store player ID for gesture handling
            cardElement.dataset.playerId = targetPlayerId;

            log(`✅ Gesture handlers set for player ${targetPlayerId}`);
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            startGesture(touch.clientX, touch.clientY, e.target);
            log(`📱 Touch start: ${touch.clientX}, ${touch.clientY}`);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!gestureState.isTracking) return;
            const touch = e.touches[0];
            updateGesture(touch.clientX, touch.clientY);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            log(`📱 Touch end`);
            endGesture();
        }

        function handleMouseStart(e) {
            startGesture(e.clientX, e.clientY, e.target);
            log(`🖱️ Mouse start: ${e.clientX}, ${e.clientY}`);
        }

        function handleMouseMove(e) {
            if (!gestureState.isTracking) return;
            updateGesture(e.clientX, e.clientY);
        }

        function handleMouseEnd(e) {
            log(`🖱️ Mouse end`);
            endGesture();
        }

        function startGesture(x, y, element) {
            gestureState.startX = x;
            gestureState.startY = y;
            gestureState.startTime = Date.now();
            gestureState.isTracking = true;
            gestureState.element = element;
            log(`🎯 Gesture started at ${x}, ${y}`);
        }

        function updateGesture(x, y) {
            if (!gestureState.isTracking) return;

            const deltaX = x - gestureState.startX;
            const deltaY = y - gestureState.startY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Visual feedback for swipe
            if (distance > 20) {
                const cardElement = gestureState.element.closest('.card-display');
                if (cardElement && deltaX > 50) {
                    cardElement.style.transform = `translateX(${Math.min(deltaX - 50, 30)}px) rotate(${Math.min((deltaX - 50) / 5, 10)}deg)`;
                    cardElement.style.opacity = '0.8';
                    log(`👉 Swipe feedback: deltaX=${deltaX}`);
                }
            }
        }

        function endGesture() {
            if (!gestureState.isTracking) return;

            const duration = Date.now() - gestureState.startTime;
            const cardElement = gestureState.element.closest('.card-display');

            log(`🎯 Gesture ended, duration: ${duration}ms`);

            if (cardElement) {
                // Check for swipe based on transform applied during updateGesture
                const transform = cardElement.style.transform || '';
                const wasSwipeRight = transform.includes('translateX') && !transform.includes('-');

                // Reset visual feedback
                cardElement.style.transform = '';
                cardElement.style.opacity = '';

                // Get the player ID from the card element's dataset
                const targetPlayerId = cardElement.dataset.playerId;
                log(`🎯 Target player ID: ${targetPlayerId}`);

                if (!targetPlayerId) {
                    log(`❌ No target player ID found in card element`);
                    gestureState.isTracking = false;
                    gestureState.element = null;
                    return;
                }

                if (wasSwipeRight) {
                    // Swipe right detected
                    log(`👉 Swipe right detected for player ${targetPlayerId}`);
                    handleSwipeRight(targetPlayerId);
                } else if (duration < 300) {
                    // Quick tap
                    if (gestureState.lastTap && Date.now() - gestureState.lastTap < 500) {
                        // Double tap - Keep card
                        log(`👆👆 Double tap detected for player ${targetPlayerId}`);
                        handleDoubleTap(targetPlayerId);
                        gestureState.lastTap = 0;
                    } else {
                        // Single tap - Look at card
                        log(`👆 Single tap detected for player ${targetPlayerId}`);
                        gestureState.lastTap = Date.now();
                        handleSingleTap(targetPlayerId);
                    }
                }
            } else {
                log(`❌ No card element found for gesture`);
            }

            // Reset gesture state
            gestureState.isTracking = false;
            gestureState.element = null;
        }

        function handleSwipeRight(targetPlayerId) {
            log(`👉 Swipe feedback: Swipe right for player ${targetPlayerId}`);
            if (targetPlayerId === playerId) {
                // Check if we can trade
                if (canPerformTrade()) {
                    const nextPlayer = getNextTradeablePlayer();
                    if (nextPlayer) {
                        log(`🔄 Trading with ${nextPlayer.name}`);
                        requestTrade(nextPlayer.id);
                    } else {
                        log(`❌ No valid trade target found`);
                        showToast('No valid trade target!', 'warning');
                    }
                } else {
                    log(`❌ Cannot trade right now`);
                    showToast('Cannot trade right now!', 'warning');
                }
            }
        }

        function handleDoubleTap(targetPlayerId) {
            log(`✅ Double tap: Processing for player ${targetPlayerId}`);
            if (targetPlayerId === playerId) {
                if (currentGame?.currentPlayerId === targetPlayerId) {
                    log(`✅ Double tap: It's my turn, keeping card`);
                    keepCard();
                } else {
                    log(`❌ Double tap: Not my turn`);
                    showToast('Not your turn!', 'warning');
                }
            }
        }

        function handleSingleTap(targetPlayerId) {
            log(`👆 Single tap: Processing for player ${targetPlayerId}`);
            if (targetPlayerId === playerId) {
                const myPlayer = currentGame?.players?.find(p => p.id === targetPlayerId);
                if (myPlayer && myPlayer.hasCard && !playerCardLooks[targetPlayerId]) {
                    log(`👁️ Single tap: Flipping card for first look`);
                    flipCard();
                    markPlayerAsLooked(targetPlayerId);
                } else {
                    log(`👁️ Single tap: Player already looked or no card`);
                }
            }
        }

        // King Logic Functions
        function isKing(card) {
            return card && (card.value === 'K' || card.value === 'King');
        }

        function isJack(card) {
            return card && (card.value === 'J' || card.value === 'Jack');
        }

        function shouldAutoRevealKing(player) {
            // For Kings, we want to auto-reveal even if already revealed locally
            return player && player.card && isKing(player.card);
        }

        function handleKingAutoReveal(player) {
            if (shouldAutoRevealKing(player)) {
                // Prevent multiple auto-reveals of the same King
                const autoRevealKey = `${player.id}-king-revealed`;
                if (window.autoRevealedKings && window.autoRevealedKings[autoRevealKey]) {
                    log(`👑 King already auto-revealed for ${player.name} - skipping`);
                    return;
                }

                // Initialize tracking if needed
                if (!window.autoRevealedKings) {
                    window.autoRevealedKings = {};
                }
                window.autoRevealedKings[autoRevealKey] = true;

                log(`👑 AUTO-REVEALING King for ${player.name}`);

                // Mark as revealed for all players to see
                player.cardRevealed = true;

                if (player.id === playerId) {
                    // Auto-flip our own King and emit to server
                    socket?.emit('auto-reveal-king', {
                        gameId: currentGame.id,
                        playerId: player.id
                    });
                }

                markPlayerAsLooked(player.id);
                showToast(`${player.name} has a King! 👑`, 'warning');

                // IMPROVED: Only auto-advance if it's actually their turn AND we're in trading phase
                setTimeout(() => {
                    if (currentGame?.currentPlayerId === player.id &&
                        (currentGame?.turnPhase === 'trading' || currentGame?.turnPhase === 'dealer-turn')) {
                        handleKingAutoAdvance(player.id);
                    } else {
                        log(`👑 Not auto-advancing ${player.name} - not their turn or wrong phase`);
                    }
                }, 500);
            }
        }

        // Auto-advance when King is revealed
        function handleKingAutoAdvance(playerId) {
            const player = currentGame?.players?.find(p => p.id === playerId);
            if (!player || !player.card || !isKing(player.card)) return;

            log(`👑 Auto-advancing ${player.name} (has King)`);

            // Check if it's actually this player's turn
            if (playerId !== currentGame?.currentPlayerId) {
                log(`👑 Not ${player.name}'s turn - skipping auto-advance`);
                return;
            }

            // Check if we're in the right phase
            if (currentGame?.turnPhase !== 'trading' && currentGame?.turnPhase !== 'dealer-turn') {
                log(`👑 Wrong phase (${currentGame?.turnPhase}) - skipping auto-advance`);
                return;
            }

            log(`👑 Auto-skipping ${player.name}'s turn (has King)`);

            // Add visual feedback
            showToast(`${player.name}'s King auto-advances! 👑`, 'success');

            // Auto-emit skip turn after a brief delay for visual feedback
            setTimeout(() => {
                if (socket && currentGame && currentGame.currentPlayerId === playerId) {
                    log(`👑 Emitting skip-turn for ${player.name}`);
                    socket.emit('skip-turn', { gameId: currentGame.id });
                } else {
                    log(`👑 Conditions changed - not emitting skip-turn`);
                }
            }, 1500);
        }

        function canPerformTrade() {
            const isMyTurn = currentGame?.currentPlayerId === playerId;
            const gameStarted = currentGame?.state === 'playing';
            const tradingPhase = currentGame?.turnPhase === 'trading';
            const myPlayer = currentGame?.players?.find(p => p.id === playerId);

            log(`🔍 Trade check: myTurn=${isMyTurn}, gameStarted=${gameStarted}, tradingPhase=${tradingPhase}`);

            // Can't trade if I have a King
            if (myPlayer?.card && isKing(myPlayer.card)) {
                log(`👑 Cannot trade: I have a King`);
                showToast('Kings cannot be traded! 👑', 'warning');
                return false;
            }

            const canTrade = isMyTurn && gameStarted && tradingPhase;
            log(`🔍 Final trade result: ${canTrade}`);
            return canTrade;
        }

        function getNextTradeablePlayer() {
            if (!currentGame?.players) return null;

            const myIndex = currentGame.players.findIndex(p => p.id === playerId);
            if (myIndex === -1) return null;

            const playerCount = currentGame.players.length;
            let nextIndex = (myIndex + 1) % playerCount;
            let searchCount = 0;

            // Find next player who doesn't have a revealed King
            while (searchCount < playerCount) {
                const nextPlayer = currentGame.players[nextIndex];

                // Check if player has revealed King
                if (nextPlayer.card && isKing(nextPlayer.card) && nextPlayer.cardRevealed) {
                    // Special case: If DEALER has King, trade with deck
                    if (nextPlayer.id === currentGame.dealerId) {
                        log(`👑 DEALER ${nextPlayer.name} has King - trade with deck!`);
                        return { id: 'TRADE_WITH_DECK', name: 'Deck', isDealer: true };
                    }
                    // Normal case: Bypass non-dealer King holders
                    else {
                        log(`👑 Bypassing ${nextPlayer.name} (has King)`);
                        nextIndex = (nextIndex + 1) % playerCount;
                        searchCount++;
                        continue;
                    }
                }

                // Valid trade target (no King or not revealed)
                if (nextPlayer.lives > 0 && nextPlayer.id !== playerId) {
                    return nextPlayer;
                }

                nextIndex = (nextIndex + 1) % playerCount;
                searchCount++;
            }

            return null;
        }

        // Card visibility function - show own cards, revealing phase cards, and auto-revealed Kings
        function shouldPlayerCardBeVisible(player) {
            // Always show your own card
            if (player.id === playerId) {
                return true;
            }

            // Show other players' cards during the revealing phase at the end of the round
            if (currentGame.turnPhase === 'revealing') {
                return true;
            }

            // 🎯 NEW: Show auto-revealed Kings during normal gameplay
            if (player.card && isKing(player.card) && player.cardRevealed) {
                return true;
            }

            // Don't show other players' cards during normal gameplay otherwise
            return false;
        }

        function canTradeWith(player) {
            if (!currentGame) return false;

            const isMyTurn = currentGame.currentPlayerId === playerId;
            const gameStarted = currentGame.state === 'playing';
            const tradingPhase = currentGame.turnPhase === 'trading';

            if (!isMyTurn || !gameStarted || !tradingPhase || player.lives <= 0) {
                return false;
            }

            const myPlayer = currentGame.players.find(p => p.id === playerId);
            if (myPlayer?.card && isKing(myPlayer.card)) {
                return false;
            }

            const nextTradeablePlayer = getNextTradeablePlayer();
            const canTrade = nextTradeablePlayer && player.id === nextTradeablePlayer.id;

            if (canTrade) {
                log(`🔄 ${player.name} is valid trade target`);
            }

            return canTrade;
        }

        // Card Look Tracking
        function markPlayerAsLooked(playerId) {
            playerCardLooks[playerId] = true;
            log(`👁️ Player ${playerId} has looked at their card`);
            clearNudge(playerId);
        }

        function hasPlayerLooked(playerId) {
            return Boolean(playerCardLooks[playerId]);
        }

        function resetCardLooks() {
            playerCardLooks = {};
            window.autoRevealedKings = {}; // Add this line
            log('🔄 Reset all card look tracking and King reveals'); // Updated log message
        }

        // Nudge System
        function startNudge(playerId, reason = 'Look at your card') {
            clearNudge(playerId); // Clear any existing nudge

            const playerElement = document.querySelector(`[data-player-id="${playerId}"]`)?.closest('.focus-slot');
            if (!playerElement) return;

            const cardElement = playerElement.querySelector('.card-display');
            if (!cardElement) return;

            log(`🔔 Starting nudge for player ${playerId}: ${reason}`);

            // Visual nudge - shake animation
            cardElement.classList.add('nudge-shake');

            // Audio nudge (optional)
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmoeAzeI1PKscBkFl3bvuKJcHA==');
                audio.volume = 0.3;
                audio.play().catch(() => { }); // Ignore audio errors
            } catch (error) {
                // Ignore audio errors
            }

            // Pulse effect
            nudgeIntervals[playerId] = setInterval(() => {
                if (cardElement.classList.contains('nudge-pulse')) {
                    cardElement.classList.remove('nudge-pulse');
                } else {
                    cardElement.classList.add('nudge-pulse');
                }
            }, 1000);

            // Auto-clear after 10 seconds
            nudgeTimeouts[playerId] = setTimeout(() => {
                clearNudge(playerId);
            }, 10000);

            // Show toast
            showToast(`${reason} 👆`, 'warning');
        }

        function clearNudge(playerId) {
            const playerElement = document.querySelector(`[data-player-id="${playerId}"]`)?.closest('.focus-slot');
            if (playerElement) {
                const cardElement = playerElement.querySelector('.card-display');
                if (cardElement) {
                    cardElement.classList.remove('nudge-shake', 'nudge-pulse');
                }
            }

            if (nudgeTimeouts[playerId]) {
                clearTimeout(nudgeTimeouts[playerId]);
                delete nudgeTimeouts[playerId];
            }

            if (nudgeIntervals[playerId]) {
                clearInterval(nudgeIntervals[playerId]);
                delete nudgeIntervals[playerId];
            }
        }

        function clearAllNudges() {
            Object.keys(nudgeTimeouts).forEach(playerId => clearNudge(playerId));
        }

        // Username validation functions
        function validatePlayerName(name) {
            if (!name || name.trim().length === 0) {
                showToast('Please enter a valid name', 'error');
                return false;
            }

            if (name.trim().length > 20) {
                showToast('Name must be 20 characters or less', 'error');
                return false;
            }

            // Check for inappropriate characters
            const validName = /^[a-zA-Z0-9\s_-]+$/.test(name.trim());
            if (!validName) {
                showToast('Name can only contain letters, numbers, spaces, underscore, and dash', 'error');
                return false;
            }

            return true;
        }

        function checkForDuplicateUsername(name) {
            if (currentGame && currentGame.players) {
                const duplicate = currentGame.players.find(p =>
                    p.name.toLowerCase().trim() === name.toLowerCase().trim() && p.id !== playerId
                );
                if (duplicate) {
                    showToast(`Name "${name}" is already taken in this game`, 'error');
                    return true;
                }
            }
            return false;
        }

        // Enhanced game state cleanup
        function cleanupGameState() {
            if (!currentGame || !currentGame.players) return;

            const originalCount = currentGame.players.length;

            // Remove duplicate players by ID
            const uniquePlayers = [];
            const seenIds = new Set();

            currentGame.players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                } else {
                    log(`🗑️ Removing duplicate player: ${player.name} (${player.id})`);
                }
            });

            if (originalCount !== uniquePlayers.length) {
                log(`🔧 Game cleanup: ${originalCount} -> ${uniquePlayers.length} players`);
                currentGame.players = uniquePlayers;

                // Update display after cleanup
                updateGameDisplay();
                updatePersonalTable();

                showToast(`Cleaned up ${originalCount - uniquePlayers.length} duplicate players`, 'success');
            }
        }

        // Available Players Management
        function renderAvailablePlayers() {
            const playersScroll = document.getElementById('playersScroll');
            if (!playersScroll) return;

            playersScroll.innerHTML = '';

            if (!currentGame || !currentGame.players) return;

            // Deduplicate players before rendering
            const uniquePlayers = [];
            const seenIds = new Set();

            currentGame.players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                }
            });

            const playerCount = uniquePlayers.length;
            if (playerCount <= 5) {
                return;
            }

            const addedPlayerIds = new Set();
            const playersNotInFocus = uniquePlayers.filter(player => {
                return !isPlayerInFocus(player.id);
            });

            playersNotInFocus.forEach(player => {
                if (addedPlayerIds.has(player.id)) {
                    return;
                }
                addedPlayerIds.add(player.id);

                const playerDiv = document.createElement('div');
                let playerClasses = 'available-player';

                if (player.id === currentGame.currentPlayerId) {
                    playerClasses += ' current-turn';
                }

                if (player.id === currentGame.dealerId) {
                    playerClasses += ' dealer';
                }

                if (canTradeWith(player)) {
                    playerClasses += ' tradeable';
                }

                // Check if player is eliminated
                if (player.lives <= 0) {
                    playerClasses += ' eliminated';
                }

                playerDiv.className = playerClasses;

                const playerNameDiv = document.createElement('div');
                playerNameDiv.className = 'player-name';
                playerNameDiv.textContent = player.name;
                playerDiv.appendChild(playerNameDiv);

                const miniCard = document.createElement('div');
                miniCard.className = 'mini-card';

                // Use the same card visibility logic
                const shouldShowCard = shouldPlayerCardBeVisible(player);

                if (player.card && shouldShowCard) {
                    const isRed = player.card.suit === '♥' || player.card.suit === '♦';
                    miniCard.className += isRed ? ' red' : ' black';
                    miniCard.textContent = `${player.card.value}${player.card.suit}`;
                } else if (player.hasCard || player.card) {
                    miniCard.className += ' face-down';
                    miniCard.textContent = '🂠';
                } else {
                    miniCard.textContent = '—';
                }
                playerDiv.appendChild(miniCard);

                const miniLivesDisplay = createLivesDisplay(player, true);
                playerDiv.appendChild(miniLivesDisplay);

                playerDiv.onclick = () => addToFocus(player);
                playersScroll.appendChild(playerDiv);
            });

            log(`✅ Rendered ${addedPlayerIds.size} available players (deduplicated)`);
        }

        function addToFocus(player) {
            if (!focusedPlayers) initializeFocusState();

            const playerCount = currentGame.players.length;

            if (playerCount <= 5) {
                log(`Auto-fill mode active - cannot manually add players`);
                return;
            }

            if (isPlayerInFocus(player.id)) {
                log(`Player ${player.name} already in focus`);
                return;
            }

            if (!focusedPlayers.custom1) {
                focusedPlayers.custom1 = player;
                log(`Added ${player.name} to custom1`);
            } else if (!focusedPlayers.custom2) {
                focusedPlayers.custom2 = player;
                log(`Added ${player.name} to custom2`);
            } else {
                focusedPlayers.custom1 = player;
                log(`Replaced custom1 with ${player.name}`);
            }

            renderPersonalTable();
            renderAvailablePlayers();

            setTimeout(() => {
                initializeVideoForPlayer(player.id);
            }, 100);
        }

        function removeFromFocus(playerId) {
            if (!focusedPlayers) return;

            const playerCount = currentGame.players.length;

            if (playerCount <= 5) {
                log(`Auto-fill mode active - cannot manually remove players`);
                return;
            }

            if (focusedPlayers.custom1 && focusedPlayers.custom1.id === playerId) {
                focusedPlayers.custom1 = null;
                log(`Removed player from custom1`);
            } else if (focusedPlayers.custom2 && focusedPlayers.custom2.id === playerId) {
                focusedPlayers.custom2 = null;
                log(`Removed player from custom2`);
            }

            renderPersonalTable();
            renderAvailablePlayers();
        }

        function isPlayerInFocus(playerId) {
            if (!focusedPlayers) return false;
            return Object.values(focusedPlayers).some(player => player && player.id === playerId);
        }

        // Personal Table management
        function updatePersonalTable() {
            if (!currentGame || !currentGame.players || !Array.isArray(currentGame.players)) return;
            if (!focusedPlayers) initializeFocusState();

            // Clean up duplicate players first
            cleanupGameState();

            const myPlayerIndex = currentGame.players.findIndex(p => p.id === playerId);
            if (myPlayerIndex === -1) {
                log(`❌ Cannot find myself (${playerId}) in players list`);
                return;
            }

            const playerCount = currentGame.players.length;
            if (playerCount < 2) return;

            log(`🔄 Updating personal table: ${playerCount} players, I am ${currentGame.players[myPlayerIndex].name} at index ${myPlayerIndex}`);

            if (playerCount <= 5) {
                autoFillAllPlayers(myPlayerIndex, playerCount);
                hideAvailablePlayersSection();
            } else {
                setupCustomFocusMode(myPlayerIndex, playerCount);
                showAvailablePlayersSection();
            }

            renderPersonalTable();
            renderAvailablePlayers();
        }

        function autoFillAllPlayers(myPlayerIndex, playerCount) {
            const players = currentGame.players;

            // Deduplicate players by ID to prevent duplicate issues
            const uniquePlayers = [];
            const seenIds = new Set();

            players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                }
            });

            log(`🔧 Deduplication: ${players.length} players -> ${uniquePlayers.length} unique players`);

            // Update currentGame with deduplicated players
            currentGame.players = uniquePlayers;

            // Recalculate indices with clean player list
            const cleanMyPlayerIndex = uniquePlayers.findIndex(p => p.id === playerId);
            const cleanPlayerCount = uniquePlayers.length;

            if (cleanMyPlayerIndex === -1) {
                log(`❌ Cannot find myself in clean players list`);
                return;
            }

            focusedPlayers.currentTurn = uniquePlayers[cleanMyPlayerIndex];

            const leftNeighborIndex = (cleanMyPlayerIndex - 1 + cleanPlayerCount) % cleanPlayerCount;
            const rightNeighborIndex = (cleanMyPlayerIndex + 1) % cleanPlayerCount;

            // Smart arrangement: prioritize living players for neighbors
            const alivePlayers = uniquePlayers.filter(p => p.lives > 0);
            const deadPlayers = uniquePlayers.filter(p => p.lives <= 0);

            if (alivePlayers.length > 1) {
                // Find my position among alive players
                const myAliveIndex = alivePlayers.findIndex(p => p.id === playerId);
                const aliveCount = alivePlayers.length;

                if (myAliveIndex !== -1) {
                    if (aliveCount === 2) {
                        // 🎯 FIXED: Special 2-player layout - no duplicates!
                        const otherPlayer = alivePlayers.find(p => p.id !== playerId);
                        focusedPlayers.leftNeighbor = null;
                        focusedPlayers.rightNeighbor = otherPlayer;
                        focusedPlayers.custom1 = null;
                        focusedPlayers.custom2 = null;

                        log(`🎯 2-player layout: Center=${uniquePlayers[cleanMyPlayerIndex]?.name}, Right=${otherPlayer?.name}`);
                    } else {
                        // Normal logic for 3+ players
                        const leftAliveIndex = (myAliveIndex - 1 + aliveCount) % aliveCount;
                        const rightAliveIndex = (myAliveIndex + 1) % aliveCount;

                        focusedPlayers.leftNeighbor = alivePlayers[leftAliveIndex];
                        focusedPlayers.rightNeighbor = alivePlayers[rightAliveIndex];

                        // Fill custom slots with remaining alive players, then dead players
                        const otherAlivePlayers = alivePlayers.filter((p, index) =>
                            index !== myAliveIndex &&
                            index !== leftAliveIndex &&
                            index !== rightAliveIndex
                        );

                        const customPlayers = [...otherAlivePlayers, ...deadPlayers];
                        focusedPlayers.custom1 = customPlayers[0] || null;
                        focusedPlayers.custom2 = customPlayers[1] || null;

                        log(`🎯 Multi-player layout: Left=${alivePlayers[leftAliveIndex]?.name}, Center=${uniquePlayers[cleanMyPlayerIndex]?.name}, Right=${alivePlayers[rightAliveIndex]?.name}`);
                    }
                }
            } else {
                // Fallback to original logic if somehow we have no alive players
                focusedPlayers.leftNeighbor = uniquePlayers[leftNeighborIndex];
                focusedPlayers.rightNeighbor = uniquePlayers[rightNeighborIndex];

                const remainingPlayers = uniquePlayers.filter((p, index) =>
                    index !== cleanMyPlayerIndex &&
                    index !== leftNeighborIndex &&
                    index !== rightNeighborIndex
                );

                focusedPlayers.custom1 = remainingPlayers[0] || null;
                focusedPlayers.custom2 = remainingPlayers[1] || null;
            }

            log(`🎯 Clean personal view: Left=${uniquePlayers[leftNeighborIndex]?.name}, Center=${uniquePlayers[cleanMyPlayerIndex]?.name}, Right=${uniquePlayers[rightNeighborIndex]?.name}`);
        }

        function setupCustomFocusMode(myPlayerIndex, playerCount) {
            const players = currentGame.players;

            // Deduplicate players by ID
            const uniquePlayers = [];
            const seenIds = new Set();

            players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                }
            });

            log(`🔧 Custom mode deduplication: ${players.length} -> ${uniquePlayers.length} unique`);

            // Update currentGame with deduplicated players
            currentGame.players = uniquePlayers;

            // Recalculate with clean data
            const cleanMyPlayerIndex = uniquePlayers.findIndex(p => p.id === playerId);
            const cleanPlayerCount = uniquePlayers.length;

            if (cleanMyPlayerIndex === -1) return;

            focusedPlayers.currentTurn = uniquePlayers[cleanMyPlayerIndex];

            const leftNeighborIndex = (cleanMyPlayerIndex - 1 + cleanPlayerCount) % cleanPlayerCount;
            const rightNeighborIndex = (cleanMyPlayerIndex + 1) % cleanPlayerCount;

            focusedPlayers.leftNeighbor = uniquePlayers[leftNeighborIndex];
            focusedPlayers.rightNeighbor = uniquePlayers[rightNeighborIndex];

            if (focusedPlayers.custom1 && !uniquePlayers.find(p => p.id === focusedPlayers.custom1.id)) {
                focusedPlayers.custom1 = null;
            }
            if (focusedPlayers.custom2 && !uniquePlayers.find(p => p.id === focusedPlayers.custom2.id)) {
                focusedPlayers.custom2 = null;
            }

            const dealer = uniquePlayers.find(p => p.id === currentGame.dealerId);
            if (dealer && !isPlayerInFocus(dealer.id)) {
                if (!focusedPlayers.custom1) {
                    focusedPlayers.custom1 = dealer;
                } else if (!focusedPlayers.custom2) {
                    focusedPlayers.custom2 = dealer;
                }
            }

            log(`🎯 Clean custom view: Left=${uniquePlayers[leftNeighborIndex]?.name}, Center=${uniquePlayers[cleanMyPlayerIndex]?.name}, Right=${uniquePlayers[rightNeighborIndex]?.name}`);
        }

        function hideAvailablePlayersSection() {
            const availableSection = document.querySelector('.available-players');
            if (availableSection) {
                availableSection.style.display = 'none';
            }
        }

        function showAvailablePlayersSection() {
            const availableSection = document.querySelector('.available-players');
            if (availableSection) {
                availableSection.style.display = 'block';
            }
        }

        function renderPersonalTable() {
            const focusGrid = document.getElementById('focusGrid');
            if (!focusGrid || !focusedPlayers) return;

            focusGrid.innerHTML = '';

            const leftSlot = createFocusSlot('slot', focusedPlayers.leftNeighbor, false);
            leftSlot.style.gridColumn = '1';
            leftSlot.style.gridRow = '1';
            focusGrid.appendChild(leftSlot);

            const centerSlot = createFocusSlot('slot', focusedPlayers.currentTurn, false);
            centerSlot.style.gridColumn = '2';
            centerSlot.style.gridRow = '1';
            focusGrid.appendChild(centerSlot);

            const rightSlot = createFocusSlot('slot', focusedPlayers.rightNeighbor, false);
            rightSlot.style.gridColumn = '3';
            rightSlot.style.gridRow = '1';
            focusGrid.appendChild(rightSlot);

            const custom1Slot = createFocusSlot('custom', focusedPlayers.custom1, true);
            custom1Slot.style.gridColumn = '1';
            custom1Slot.style.gridRow = '2';
            focusGrid.appendChild(custom1Slot);

            const custom2Slot = createFocusSlot('custom', focusedPlayers.custom2, true);
            custom2Slot.style.gridColumn = '3';
            custom2Slot.style.gridRow = '2';
            focusGrid.appendChild(custom2Slot);

            // Add dealer turn notification
            // FIX: Clear any existing dealer notifications first
            const existingNotification = document.querySelector('.dealer-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            // Add dealer turn notification ONLY when it's actually the dealer's turn
            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId && currentGame?.state === 'playing';

            // Replace the big banner with a small corner badge
            if (isDealerTurn) {
                const dealerBadge = document.createElement('div');
                dealerBadge.className = 'dealer-badge';
                dealerBadge.style.cssText = `
                    position: absolute;
                    top: 8px;
                    right: 8px;
                    background: linear-gradient(45deg, #f39c12, #e67e22);
                    color: white;
                    padding: 4px 8px;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 0.6rem;
                    box-shadow: 0 2px 6px rgba(243, 156, 18, 0.4);
                    z-index: 10;
                    animation: pulse 2s infinite;
                    border: 1px solid rgba(255,255,255,0.3);
                `;
                dealerBadge.textContent = '🏁 FINAL';

                // Add to the center slot (current player's card area)
                const centerSlot = document.querySelector('[data-player-id="' + playerId + '"]')?.closest('.focus-slot');
                if (centerSlot) {
                    centerSlot.style.position = 'relative';
                    centerSlot.appendChild(dealerBadge);
                }
            }
        }

        function createFocusSlot(type, player, removable) {
            const slot = document.createElement('div');
            let slotClasses = `focus-slot ${type}`;

            if (!player) {
                slot.classList.add('empty');
                slot.innerHTML = `
                    <div class="add-icon">+</div>
                    <div>Tap player below</div>
                `;
                return slot;
            }

            if (player.id === currentGame?.currentPlayerId) {
                slotClasses += ' current-turn';
            }

            if (player.id === currentGame?.dealerId) {
                slotClasses += ' dealer';
            }

            // Check if player is eliminated
            if (player.lives <= 0) {
                slotClasses += ' eliminated';
            }

            slot.className = slotClasses;

            // Add eliminated indicator if player is dead
            if (player && player.lives <= 0) {
                const eliminatedIndicator = document.createElement('div');
                eliminatedIndicator.className = 'eliminated-indicator';
                eliminatedIndicator.textContent = 'ELIMINATED';
                slot.appendChild(eliminatedIndicator);
            }

            const playerContent = document.createElement('div');
            playerContent.className = 'player-content';

            const cardSection = document.createElement('div');
            cardSection.className = 'card-section';

            const playerInfo = document.createElement('div');
            playerInfo.className = 'player-info';
            const dealerText = (player.id === currentGame?.dealerId) ? ' (Dealer)' : '';
            playerInfo.innerHTML = `<span class="player-name">${player.name}${dealerText}</span>`;

            const livesDisplay = createLivesDisplay(player, false);
            playerInfo.appendChild(livesDisplay);

            const cardDisplay = document.createElement('div');
            cardDisplay.className = 'card-display';

            // Card visibility logic - only show other players' cards during revealing phase
            const shouldShowCard = shouldPlayerCardBeVisible(player);

            if (player.id === playerId) {
                log(`🎴 My card state: hasCard=${player.hasCard}, card=${player.card ? `${player.card.value}${player.card.suit}` : 'null'}, revealed=${player.cardRevealed}, shouldShow=${shouldShowCard}`);
            }

            if (player.card && shouldShowCard && player.lives > 0) {
                const card = player.card;
                const isRed = card.suit === '♥' || card.suit === '♦';
                let cardClasses = isRed ? ' red revealed' : ' black revealed';

                if (isKing(card)) {
                    cardClasses += ' king-auto';
                }

                cardDisplay.className += cardClasses;

                const cardContent = document.createElement('div');
                cardContent.className = 'card-content';
                cardContent.innerHTML = `
                    <div class="card-value">${card.value}</div>
                    <div class="card-suit">${card.suit}</div>
                `;
                cardDisplay.appendChild(cardContent);
            } else if ((player.hasCard || player.card) && player.lives > 0) {
                cardDisplay.className += ' face-down';
                cardDisplay.textContent = '🂠';

                // Only add gesture handlers for my own card
                if (player.id === playerId) {
                    setTimeout(() => {
                        initializeGestureHandlers(cardDisplay, player.id);
                    }, 100);
                }

                if (player.id !== playerId && !hasPlayerLooked(player.id) && player.hasCard) {
                    setTimeout(() => {
                        if (!hasPlayerLooked(player.id)) {
                            startNudge(player.id, `${player.name} should look at their card`);
                        }
                    }, 2000);
                }
            } else {
                cardDisplay.textContent = 'No Card';
            }

            cardSection.appendChild(playerInfo);
            cardSection.appendChild(cardDisplay);
            cardSection.setAttribute('data-player-id', player.id);

            // Add action buttons for my own card
            if (player.id === playerId) {
                const actionContainer = document.createElement('div');
                actionContainer.style.display = 'flex';
                actionContainer.style.gap = '4px';
                actionContainer.style.marginTop = '4px';

                const myPlayer = currentGame?.players?.find(p => p.id === playerId);
                const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
                const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

                // Keep Card button
                const keepBtn = document.createElement('button');
                keepBtn.className = 'action-button';
                keepBtn.style.fontSize = '0.6rem';
                keepBtn.style.padding = '4px 6px';
                keepBtn.disabled = currentGame?.currentPlayerId !== playerId;

                // Update button for dealer turn
                if (isDealerTurn) {
                    keepBtn.textContent = '✋ Keep & End';
                    keepBtn.style.background = '#f39c12';
                } else {
                    keepBtn.textContent = '✋ Keep';
                    keepBtn.style.background = '#27ae60';
                }

                keepBtn.onclick = () => {
                    log(`✋ Card-level keep button clicked (dealer: ${isDealerTurn})`);
                    if (isDealerTurn) {
                        // Dealer keep = end round
                        socket.emit('dealer-skip-trade', { gameId: currentGame.id });
                        showToast('Dealer kept card - Round ending!', 'success');
                    } else {
                        keepCard();
                    }
                };
                actionContainer.appendChild(keepBtn);

                // Trade button
                const tradeBtn = document.createElement('button');
                tradeBtn.className = 'action-button trade';
                tradeBtn.style.fontSize = '0.6rem';
                tradeBtn.style.padding = '4px 6px';
                tradeBtn.disabled = !canPerformTrade() && !isDealerTurn;

                // Update button for dealer turn
                if (isDealerTurn) {
                    tradeBtn.textContent = '🎴 Deck';
                    tradeBtn.style.background = '#e74c3c';
                } else {
                    tradeBtn.textContent = '🔄 Trade';
                    tradeBtn.style.background = '#3498db';
                }

                tradeBtn.onclick = () => {
                    log(`🔄 Card-level trade button clicked (dealer: ${isDealerTurn})`);
                    if (isDealerTurn) {
                        // Dealer trade with deck
                        socket.emit('dealer-trade-deck', { gameId: currentGame.id });
                        showToast('Trading with deck...', 'info');
                    } else {
                        const nextPlayer = getNextTradeablePlayer();
                        if (nextPlayer) {
                            requestTrade(nextPlayer.id);
                        } else {
                            showToast('No valid trade target!', 'warning');
                        }
                    }
                };
                actionContainer.appendChild(tradeBtn);

                cardSection.appendChild(actionContainer);
            }

            // Add trade button for other players I can trade with
            if (player.id !== playerId && canTradeWith(player)) {
                const actionBtn = document.createElement('button');
                actionBtn.className = 'action-button trade';
                actionBtn.textContent = 'Trade →';
                actionBtn.onclick = () => {
                    log(`🔄 Trading with ${player.name}`);
                    requestTrade(player.id);
                };
                cardSection.appendChild(actionBtn);
            }

            const videoSection = document.createElement('div');
            videoSection.className = 'video-section';

            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';
            const videoElement = document.createElement('div');
            videoElement.className = 'video-element';
            videoElement.id = `video-${player.id}`;

            const placeholder = document.createElement('div');
            placeholder.className = 'video-placeholder';
            placeholder.textContent = '📹';
            videoElement.appendChild(placeholder);

            const videoControls = document.createElement('div');
            videoControls.className = 'video-controls';
            videoControls.innerHTML = `
                <button class="video-control-btn" onclick="startVideoForPlayer('${player.id}')" title="Start Video">📷</button>
                <button class="video-control-btn" onclick="toggleMuteForPlayer('${player.id}')" title="Mute">🎤</button>
                <button class="video-control-btn" onclick="endVideoForPlayer('${player.id}')" title="End">❌</button>
            `;

            videoContainer.appendChild(videoElement);
            videoContainer.appendChild(videoControls);
            videoSection.appendChild(videoContainer);

            playerContent.appendChild(cardSection);
            playerContent.appendChild(videoSection);
            slot.appendChild(playerContent);

            // Add remove button for removable slots
            if (removable) {
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-button';
                removeBtn.textContent = '×';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeFromFocus(player.id);
                };
                slot.appendChild(removeBtn);
            }

            return slot;
        }

        // Video Controls
        function startVideoForPlayer(playerId) {
            if (playerId === playerId) {
                initializeVideoCall();
            }
            showToast(`📹 Video starting for player`, 'info');
        }

        function toggleMuteForPlayer(playerId) {
            if (playerId === playerId && localAudioTrack) {
                const enabled = localAudioTrack.enabled;
                localAudioTrack.setEnabled(!enabled);
                showToast(`🎤 ${enabled ? 'Muted' : 'Unmuted'}`, 'info');

                const btn = document.querySelector(`[onclick="toggleMuteForPlayer('${playerId}')"]`);
                if (btn) {
                    btn.className = enabled ? 'video-control-btn muted' : 'video-control-btn';
                    btn.textContent = enabled ? '🔇' : '🎤';
                }
            }
        }

        function endVideoForPlayer(playerId) {
            if (playerId === playerId) {
                leaveVideoCall();
            }
            showToast(`📹 Video ended for player`, 'info');
        }

        // Enhanced Game action handlers
        function handleFlipClick() {
            log(`🎴 Flip Card button clicked`);
            flipCard();
        }

        function handleKeepClick() {
            log(`✋ Keep Card button clicked`);
            if (currentGame?.currentPlayerId !== playerId) {
                log(`❌ Not my turn! Current turn: ${currentGame?.currentPlayerId}, Me: ${playerId}`);
                showToast('Not your turn!', 'warning');
                return;
            }

            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

            // Handle dealer keep (should end round)
            if (isDealerTurn) {
                log(`✋ Dealer keeping card - this should END the round`);
                if (!socket || !currentGame) {
                    log(`❌ Dealer keep failed: no socket or game`);
                    return;
                }

                // Emit dealer skip trade (keep card)
                socket.emit('dealer-skip-trade', { gameId: currentGame.id });
                showToast('Dealer kept card - Round ending!', 'success');
                return;
            }

            // Normal keep card logic
            keepCard();
        }

        function handleTradeClick() {
            log(`🔄 Trade Card button clicked`);

            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

            // Handle dealer deck trading
            if (isDealerTurn) {
                log(`🎴 Dealer trading with deck`);
                if (!socket || !currentGame) {
                    log(`❌ Dealer deck trade failed: no socket or game`);
                    return;
                }

                // Emit dealer deck trade
                socket.emit('dealer-trade-deck', { gameId: currentGame.id });
                showToast('Trading with deck...', 'info');
                return;
            }

            // Normal player trading logic
            if (!canPerformTrade()) {
                log(`❌ Cannot trade right now`);
                showToast('Cannot trade right now!', 'warning');
                return;
            }

            const nextPlayer = getNextTradeablePlayer();
            if (nextPlayer) {
                log(`🔄 Trading with ${nextPlayer.name}`);
                requestTrade(nextPlayer.id);
            } else {
                log(`❌ No valid trade target`);
                showToast('No valid trade target!', 'warning');
            }
        }

        // Game actions
        function startGame() {
            if (!socket || !currentGame) {
                showToast('Game not ready', 'error');
                return;
            }

            if (currentGame.hostId !== playerId) {
                showToast('Only the host can start the game', 'error');
                return;
            }

            const settings = { startingLives: 3, deckCount: 1 };

            socket.emit('start-game', {
                gameId: currentGame.id,
                settings
            });
            log('🚀 Starting game...');
        }

        function flipCard() {
            if (!socket || !currentGame) {
                log(`❌ Flip card failed: no socket or game`);
                return;
            }

            log(`🎴 Flipping card for player ${playerId}`);
            socket.emit('flip-card', { gameId: currentGame.id });

            markPlayerAsLooked(playerId);
        }

        function keepCard() {
            if (!socket || !currentGame) {
                log(`❌ Keep card failed: no socket or game`);
                return;
            }

            // Check if it's actually my turn
            if (currentGame.currentPlayerId !== playerId) {
                log(`❌ Keep card failed: not my turn (current: ${currentGame.currentPlayerId}, me: ${playerId})`);
                showToast('Not your turn!', 'warning');
                return;
            }

            const myPlayer = currentGame.players?.find(p => p.id === playerId);
            if (myPlayer?.card && isKing(myPlayer.card)) {
                log('👑 Keeping King (automatic)');
                showToast('Keeping your King! 👑', 'success');
            } else {
                log('✋ Keeping your card...');
            }

            socket.emit('skip-turn', { gameId: currentGame.id });
        }

        function requestTrade(targetPlayerId) {
            if (!socket || !currentGame) return;

            if (!canPerformTrade()) {
                log(`❌ Cannot perform trade right now`);
                return;
            }

            if (targetPlayerId === 'TRADE_WITH_DECK') {
                log(`🎴 Special case: Trading with deck because dealer has King`);
                socket.emit('trade-with-deck-special', {
                    gameId: currentGame.id
                });
                return;
            }

            if (!hasPlayerLooked(targetPlayerId)) {
                const targetPlayer = currentGame.players.find(p => p.id === targetPlayerId);
                const targetName = targetPlayer?.name || 'Player';

                log(`🔔 ${targetName} must look at their card first!`);
                showToast(`${targetName} must look at their card first! 👆`, 'warning');

                startNudge(targetPlayerId, `${targetName}, look at your card before trade!`);
                return;
            }

            log(`🔄 Requesting trade: ${playerId} → ${targetPlayerId}`);

            socket.emit('trade-request', {
                gameId: currentGame.id,
                targetPlayerId
            });
        }

        function endRound() {
            if (!socket || !currentGame) return;
            socket.emit('end-round', { gameId: currentGame.id });
            log('⏰ Ending round...');
        }

        function leaveGame() {
            if (confirm('Are you sure you want to leave the game?')) {
                leaveVideoCall().catch(console.error);
                completeCleanup();
                showMainMenu();
                log('🚪 Left game and cleaned up completely');
            }
        }

        // Chat functions
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();

            if (message && socket) {
                socket.emit('game-chat', {
                    gameId: currentGame.id,
                    message
                });
                chatInput.value = '';
            }
        }

        // Video integration (add your Agora token)
        function initializeVideoCall() {
            if (isVideoJoined) return;

            log('📹 Initializing video call...');

            // Check if Agora SDK is loaded
            if (typeof AgoraRTC === 'undefined') {
                log('❌ Agora SDK not loaded - video features disabled');
                showToast('Video features unavailable - Agora SDK not loaded', 'warning');
                return;
            }

            try {
                agoraClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
                log('📹 Agora client created successfully');

                agoraClient.on("user-published", handleUserPublished);
                agoraClient.on("user-unpublished", handleUserUnpublished);
                agoraClient.on("user-left", handleUserLeft);
                log('📹 Event listeners added');

                joinVideoChannel();
            } catch (error) {
                log(`❌ Error initializing video: ${error.message}`);
                showToast('Video initialization failed - continuing without video', 'warning');
            }
        }

        async function joinVideoChannel() {
            try {
                const channelName = currentGame?.gameCode || currentGame?.id || 'test123';
                const uid = Math.floor(Math.random() * 1000000);
                const appId = 'cfef8101dcc14802a8f97d8805b3ebc9'; // Add your app ID here

                if (appId === 'YOUR_AGORA_APP_ID') {
                    log('❌ Agora App ID not configured - video disabled');
                    showToast('Video disabled: Configure Agora App ID', 'warning');
                    return;
                }

                log(`📹 Attempting to join channel: ${channelName}`);

                await agoraClient.join(appId, channelName, '007eJxTYCi5bLt+duriRK4T85Nu9B/k8hCvZnPIt9rqIntDbY3SozIFhuS01DQLQwPDlORkQxMLA6NEizRL8xQLCwPTJOPUpGTL1N+pGQ2BjAyHIuYzMTJAIIjPzlCSWlxiaGTMwAAAaO4flA==', uid);
                log('📹 Successfully joined channel');

                try {
                    localVideoTrack = await AgoraRTC.createCameraVideoTrack();
                    localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                    log('📹 Media tracks created');

                    const myVideoElement = document.getElementById(`video-${playerId}`);
                    if (myVideoElement && localVideoTrack) {
                        localVideoTrack.play(myVideoElement);
                        const placeholder = myVideoElement.querySelector('.video-placeholder');
                        if (placeholder) placeholder.remove();
                    }

                    await agoraClient.publish([localVideoTrack, localAudioTrack]);
                    log('📹 Tracks published successfully');

                    isVideoJoined = true;
                    log('📹 Video call started successfully');

                } catch (mediaError) {
                    log(`❌ Media error: ${mediaError.message}`);
                    showToast('Camera/microphone access denied - video disabled', 'warning');
                }

            } catch (error) {
                log(`❌ Error joining video channel: ${error.message}`);
                showToast('Failed to join video call - continuing without video', 'warning');
            }
        }

        // FIXED: Properly defined handleUserPublished function
        async function handleUserPublished(user, mediaType) {
            try {
                log(`📹 ${user.uid} started ${mediaType}`);
                await agoraClient.subscribe(user, mediaType);

                if (mediaType === 'video') {
                    const videoElement = document.getElementById(`video-${user.uid}`);
                    if (videoElement && user.videoTrack) {
                        user.videoTrack.play(videoElement);
                        const placeholder = videoElement.querySelector('.video-placeholder');
                        if (placeholder) placeholder.remove();
                    }
                }

                remoteUsers[user.uid] = user;
            } catch (error) {
                log(`❌ Error handling user published: ${error.message}`);
            }
        }

        function handleUserUnpublished(user, mediaType) {
            log(`📹 ${user.uid} stopped ${mediaType}`);

            if (mediaType === 'video') {
                const videoElement = document.getElementById(`video-${user.uid}`);
                if (videoElement) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'video-placeholder';
                    placeholder.textContent = '📹';
                    videoElement.innerHTML = '';
                    videoElement.appendChild(placeholder);
                }
            }
        }

        function handleUserLeft(user) {
            log(`👋 ${user.uid} left video call`);
            delete remoteUsers[user.uid];

            const videoElement = document.getElementById(`video-${user.uid}`);
            if (videoElement) {
                const placeholder = document.createElement('div');
                placeholder.className = 'video-placeholder';
                placeholder.textContent = '📹';
                videoElement.innerHTML = '';
                videoElement.appendChild(placeholder);
            }
        }

        function initializeVideoForPlayer(playerId) {
            const remoteUser = remoteUsers[playerId];
            if (remoteUser && remoteUser.videoTrack) {
                const videoElement = document.getElementById(`video-${playerId}`);
                if (videoElement) {
                    remoteUser.videoTrack.play(videoElement);
                    const placeholder = videoElement.querySelector('.video-placeholder');
                    if (placeholder) placeholder.remove();
                }
            }
        }

        async function leaveVideoCall() {
            if (!isVideoJoined) return;

            try {
                log('📹 Leaving video call...');

                if (localVideoTrack) {
                    localVideoTrack.stop();
                    localVideoTrack.close();
                }

                if (localAudioTrack) {
                    localAudioTrack.stop();
                    localAudioTrack.close();
                }

                if (agoraClient) {
                    await agoraClient.leave();
                }

                isVideoJoined = false;
                remoteUsers = {};
                log('📹 Left video call');

            } catch (error) {
                log(`❌ Error leaving video call: ${error.message}`);
            }
        }

        // Complete cleanup function
        function completeCleanup() {
            log('🧹 Performing complete cleanup...');

            // 1. Disconnect socket completely
            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
                socket = null;
            }

            // 2. Clear ALL game state
            currentGame = null;
            playerId = null;
            lastGameState = null;

            // 3. Reinitialize focus state completely
            initializeFocusState();

            // 4. Clear video state
            videoStates = {};
            remoteUsers = {};
            isVideoJoined = false;

            // 5. Clear gesture and King logic state
            playerCardLooks = {};
            gestureState = {
                startX: 0,
                startY: 0,
                startTime: 0,
                isTracking: false,
                element: null,
                lastTap: 0
            };
            clearAllNudges();

            // 6. Clear all UI elements
            const focusGrid = document.getElementById('focusGrid');
            if (focusGrid) focusGrid.innerHTML = '';

            const playersScroll = document.getElementById('playersScroll');
            if (playersScroll) playersScroll.innerHTML = '';

            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) chatMessages.innerHTML = '';

            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages) gameMessages.innerHTML = '';

            // 7. Reset connection status
            const connectionStatus = document.getElementById('connectionStatus');
            if (connectionStatus) connectionStatus.innerHTML = '🔴 Disconnected';

            // 8. Clear any timeouts
            if (updateTimeout) {
                clearTimeout(updateTimeout);
                updateTimeout = null;
            }

            log('🧹 Complete cleanup finished');
        }

        // Menu navigation
        function showMainMenu() {
            completeCleanup();
            document.querySelectorAll('.menu-screen, #gameContent').forEach(el => el.classList.add('hidden'));
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function showQuickMatch() {
            completeCleanup();
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('quick-match').classList.remove('hidden');

            setTimeout(() => {
                connectToServer();
                setTimeout(() => {
                    createPublicGame();
                }, 1000);
            }, 100);
        }

        function showCreateGame() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('create-game').classList.remove('hidden');
        }

        function showJoinGame() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('join-game').classList.remove('hidden');
        }

        function showGameContent() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('gameContent').classList.remove('hidden');
        }

        // Server connection
        function connectToServer() {
            log('🔄 Creating FRESH server connection...');

            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
                socket = null;
            }

            // Connect to your backend server on port 3001
            const serverUrl = window.location.hostname === 'localhost' ?
                'http://localhost:3001' :
                window.location.origin;

            socket = io(serverUrl, {
                transports: ['websocket', 'polling'],
                timeout: 60000,  // 60 seconds for mobile
                reconnection: true,
                reconnectionDelay: 3000,  // Wait 3 seconds before trying
                reconnectionAttempts: 15,  // Try 15 times
                maxReconnectionAttempts: 15,
                reconnectionDelayMax: 15000,  // Max 15 second delay
                randomizationFactor: 0.5,
                forceNew: true,
                // Mobile-optimized settings
                pingTimeout: 90000,  // 90 seconds for ping timeout
                pingInterval: 30000,  // Ping every 30 seconds
                upgradeTimeout: 45000  // 45 seconds for upgrade timeout
            });

            // Mobile background/foreground handling
            let isAppInBackground = false;
            let reconnectOnForeground = false;

            // Detect when app goes to background/foreground
            document.addEventListener('visibilitychange', function () {
                if (document.hidden) {
                    // App went to background
                    isAppInBackground = true;
                    log('📱 App went to background - preparing for potential disconnect');

                    // Save current state
                    if (currentGame && playerId) {
                        localStorage.setItem('gameReconnectData', JSON.stringify({
                            gameId: currentGame.id,
                            playerId: playerId,
                            playerName: playerName,
                            timestamp: Date.now()
                        }));
                    }
                } else {
                    // App came back to foreground
                    isAppInBackground = false;
                    log('📱 App returned to foreground - checking connection');

                    // Check if we need to reconnect
                    if (socket && !socket.connected && currentGame) {
                        log('📱 Socket disconnected while in background - attempting reconnect');
                        reconnectOnForeground = true;
                        attemptMobileReconnection();
                    }
                }
            });

            // Mobile heartbeat system functions
            let heartbeatInterval = null;

            function startMobileHeartbeat() {
                if (heartbeatInterval) clearInterval(heartbeatInterval);

                heartbeatInterval = setInterval(() => {
                    if (socket && socket.connected && !isAppInBackground) {
                        socket.emit('heartbeat', {
                            timestamp: Date.now(),
                            gameId: currentGame?.id,
                            playerId: playerId
                        });
                    }
                }, 30000); // Every 30 seconds
            }

            function stopMobileHeartbeat() {
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = null;
                }
            }

            function attemptMobileReconnection() {
                if (!currentGame || !playerId) {
                    log('📱 No game state to reconnect to');
                    return;
                }

                log('📱 Attempting mobile reconnection...');
                showToast('Reconnecting...', 'info');

                // Try to reconnect the socket
                if (socket) {
                    socket.removeAllListeners();
                    socket.disconnect();
                    socket = null;
                }

                // Create fresh connection
                connectToServer();

                // Set up one-time connection handler for reconnection
                const reconnectHandler = () => {
                    log('📱 Socket reconnected - checking for existing game');

                    // Give server a moment to process connection
                    setTimeout(() => {
                        socket.emit('check-reconnect', {
                            userId: playerId,
                            gameId: currentGame.id
                        });
                    }, 500);

                    // Remove this handler after use
                    socket.off('connect', reconnectHandler);
                };

                if (socket) {
                    socket.on('connect', reconnectHandler);

                    // Add timeout for reconnection attempt
                    setTimeout(() => {
                        if (socket && !socket.connected) {
                            log('📱 Mobile reconnection timeout - may need manual refresh');
                            showToast('Connection timeout - tap refresh if needed', 'error');
                        }
                    }, 15000);
                }
            }

            // Network change detection for mobile
            window.addEventListener('online', function () {
                log('📱 Network connection restored');
                if (socket && !socket.connected && currentGame) {
                    log('📱 Attempting reconnection after network restoration');
                    setTimeout(() => {
                        attemptMobileReconnection();
                    }, 1000);
                }
            });

            window.addEventListener('offline', function () {
                log('📱 Network connection lost');
                showToast('Network connection lost - will reconnect automatically', 'warning');
            });

            // Socket event handlers
            socket.on('connect', () => {
                log('✅ FRESH connection established! ID: ' + socket.id);
                document.getElementById('connectionStatus').innerHTML = '🟢 Connected';

                playerName = document.getElementById('playerName').value || 'Player';

                // Start mobile heartbeat
                startMobileHeartbeat();

                // RECONNECTION: Check if we were previously in a game
                if (playerId && currentGame) {
                    log('🔄 Checking for reconnection...');
                    socket.emit('check-reconnect', { userId: playerId });
                } else {
                    playerId = socket.id;
                }

                // Clear reconnection flag
                reconnectOnForeground = false;
            });

            socket.on('disconnect', (reason) => {
                log(`❌ Disconnected: ${reason}`);
                document.getElementById('connectionStatus').innerHTML = '🔴 Disconnected';

                // Stop heartbeat when disconnected
                stopMobileHeartbeat();

                // Handle mobile-specific disconnect reasons
                if (reason === 'transport close' || reason === 'ping timeout' || reason === 'transport error') {
                    log('📱 Mobile-style disconnect detected');

                    if (!isAppInBackground && currentGame) {
                        // Immediate reconnection attempt for foreground disconnects
                        showToast('Connection lost - reconnecting...', 'warning');
                        setTimeout(() => {
                            if (!socket || !socket.connected) {
                                log('📱 Auto-reconnecting after mobile disconnect');
                                attemptMobileReconnection();
                            }
                        }, 2000);
                    } else {
                        // Flag for reconnection when app comes back to foreground
                        reconnectOnForeground = true;
                        log('📱 Will reconnect when app returns to foreground');
                    }
                } else {
                    // Handle other disconnect reasons
                    log(`📱 Non-mobile disconnect: ${reason}`);
                    if (currentGame) {
                        showToast('Disconnected - trying to reconnect...', 'error');
                        setTimeout(() => {
                            if (!socket || !socket.connected) {
                                attemptMobileReconnection();
                            }
                        }, 3000);
                    }
                }

                if (isVideoJoined) {
                    leaveVideoCall().catch(console.error);
                }
            });

            socket.on('connect_error', (error) => {
                log(`❌ Connection error: ${error.message}`);
                showToast('Connection failed. Make sure server is running on port 3001.', 'error');
            });

            // Add heartbeat response handler
            socket.on('heartbeat-ack', (data) => {
                // Update connection status to show healthy connection
                document.getElementById('connectionStatus').innerHTML = '🟢 Connected';
            });

            // ===== GAME CREATION & JOINING EVENTS =====
            socket.on('public-game-created', function (data) {
                log('🎮 FRESH public game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();
            });

            socket.on('private-game-created', function (data) {
                log('🎮 FRESH private game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();

                if (data.friendCode) {
                    showToast(`Game Code: ${data.friendCode}`, 'success');
                }
            });

            socket.on('game-created', function (data) {
                log('🎮 FRESH game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();

                if (data.friendCode) {
                    showToast(`Game Code: ${data.friendCode}`, 'success');
                }
            });

            socket.on('game-joined', function (data) {
                log('🎮 Joined game! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();

                if (currentGame.hostId === playerId) {
                    showHostControls();
                }
            });

            socket.on('auto-rejoined', function (data) {
                log('🔄 Auto-rejoined game successfully!');
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showToast('Reconnected to game!', 'success');
            });

            socket.on('player-reconnected', function (data) {
                log(`🔄 ${data.playerName} reconnected to game`);
                showToast(`${data.playerName} reconnected!`, 'success');
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('player-joined', function (data) {
                log(`👋 Player joined: ${data.newPlayer?.name || 'Unknown'}`);
                currentGame = data.game;

                // Check for duplicate players and warn
                if (currentGame.players) {
                    const playerNames = currentGame.players.map(p => p.name);
                    const playerIds = currentGame.players.map(p => p.id);
                    const duplicateNames = playerNames.filter((name, index) => playerNames.indexOf(name) !== index);
                    const duplicateIds = playerIds.filter((id, index) => playerIds.indexOf(id) !== index);

                    if (duplicateNames.length > 0) {
                        log(`⚠️ WARNING: Duplicate player names detected: ${duplicateNames.join(', ')}`);
                    }
                    if (duplicateIds.length > 0) {
                        log(`⚠️ WARNING: Duplicate player IDs detected: ${duplicateIds.join(', ')}`);
                    }
                }

                updateGameDisplay();
                updatePersonalTable();
            });

            // ===== GAME FLOW EVENTS =====
            socket.on('game-started', function (data) {
                log('🎮 Game started!');
                currentGame = data.game;

                resetCardLooks();
                clearAllNudges();

                hideHostControls();
                updateGameDisplay();
                updatePersonalTable();

                setTimeout(() => {
                    initializeVideoCall();
                }, 1000);
            });

            socket.on('round-started', function (data) {
                log(`🔄 New round started!`);
                currentGame = data.game;

                resetCardLooks();
                clearAllNudges();

                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('cards-dealt', function (data) {
                log('🎴 Cards dealt!');
                currentGame = data.game;

                resetCardLooks();
                clearAllNudges();

                // Check for any Kings that should auto-reveal
                if (currentGame.players) {
                    currentGame.players.forEach(player => {
                        if (shouldAutoRevealKing(player)) {
                            setTimeout(() => handleKingAutoReveal(player), 500);
                        }
                    });
                }

                // ADD THIS: Check if current player has King and auto-advance
                const currentPlayer = currentGame.players?.find(p => p.id === currentGame.currentPlayerId);
                if (currentPlayer && shouldAutoRevealKing(currentPlayer)) {
                    log(`👑 Current player ${currentPlayer.name} has King after cards dealt - auto-advancing`);
                    setTimeout(() => handleKingAutoAdvance(currentPlayer.id), 1500);
                }

                updateGameDisplay();
                updatePersonalTable();

                // Start nudging players who haven't looked at their cards
                setTimeout(() => {
                    if (currentGame.players) {
                        currentGame.players.forEach(player => {
                            if (player.hasCard && !hasPlayerLooked(player.id) && player.id !== playerId) {
                                startNudge(player.id, `${player.name} should look at their card`);
                            }
                        });
                    }
                }, 3000);
            });

            // ===== SPECIAL KING & JACK EVENTS =====
            socket.on('king-auto-revealed', function (data) {
                log(`👑 King auto-revealed for player ${data.playerId}`);
                const player = currentGame.players?.find(p => p.id === data.playerId);
                if (player) {
                    player.cardRevealed = true;
                    markPlayerAsLooked(data.playerId);
                    updateGameDisplay();