<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screw Your Neighbor - Personal Table</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 10px 0;
            border-bottom: 2px solid rgba(255,255,255,0.2);
            margin-bottom: 15px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        .game-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            opacity: 0.9;
            flex-wrap: wrap;
        }

        /* Personal Table Layout */
        .personal-table {
            margin-bottom: 15px;
        }

        .focus-grid {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr;
            grid-template-rows: auto auto;
            gap: 8px;
            margin-bottom: 15px;
        }

        .focus-slot {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 8px;
            min-height: 140px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .focus-slot.current-turn {
            border-color: #00FF00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(0,255,0,0.3); }
            50% { box-shadow: 0 0 25px rgba(0,255,0,0.6); }
        }

        .focus-slot.custom {
            border-color: #FFD700;
            grid-row: 2;
        }

        .focus-slot.custom:first-of-type {
            grid-column: 1;
        }

        .focus-slot.custom:last-of-type {
            grid-column: 3;
        }

        .focus-slot.dealer {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255,215,0,0.4);
        }

        .focus-slot.empty {
            border: 2px dashed rgba(255,255,255,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
        }

        .focus-slot.empty .add-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        /* Card + Video Side-by-Side Layout */
        .player-content {
            display: flex;
            gap: 8px;
            align-items: stretch;
            height: 100%;
        }

        .card-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .video-section {
            width: 80px;
            flex-shrink: 0;
        }

        .video-container {
            width: 100%;
            height: 60px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #222;
        }

        .video-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #555);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.5);
            font-size: 0.7rem;
        }

        /* Enhanced Video Controls */
        .video-controls {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            gap: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .focus-slot:hover .video-controls {
            opacity: 1;
        }

        .video-control-btn {
            padding: 1px 2px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: none;
            border-radius: 2px;
            font-size: 0.5rem;
            cursor: pointer;
            transition: background 0.3s ease;
            flex: 1;
        }

        .video-control-btn:hover {
            background: rgba(0,0,0,1);
        }

        .video-control-btn.active {
            background: #4caf50;
        }

        .video-control-btn.muted {
            background: #f44336;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }

        .player-name {
            font-weight: bold;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-lives {
            background: rgba(255,0,0,0.8);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        /* Playing Card Design - Proper Card Proportions */
        .card-display {
            width: 80px;
            height: 110px;
            background: linear-gradient(145deg, #ffffff, #f8f8f8);
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            margin: 8px auto;
            transition: all 0.3s ease;
            font-family: 'Times New Roman', serif;
            font-size: 1rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .card-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .card-display.face-down {
            background: linear-gradient(145deg, #1a237e, #303f9f);
            color: white;
            font-size: 1.5rem;
        }

        .card-display.face-down:hover {
            transform: scale(1.05);
        }

        .card-display.red {
            color: #d32f2f;
            background: linear-gradient(145deg, #ffffff, #fafafa);
        }

        .card-display.black {
            color: #212121;
            background: linear-gradient(145deg, #ffffff, #fafafa);
        }

        .card-display.revealed {
            box-shadow: 0 0 15px rgba(255,215,0,0.6);
            transform: scale(1.02);
        }

        /* NEW: Nudge Animations */
        .nudge-shake {
            animation: shake 0.5s ease-in-out infinite;
        }

        .nudge-pulse {
            animation: pulse-glow 1s ease-in-out;
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 20px rgba(255,215,0,0.8) !important;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px) rotate(-1deg); }
            75% { transform: translateX(3px) rotate(1deg); }
        }

        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(255,215,0,0.4);
                border-color: rgba(255,215,0,0.6);
            }
            50% { 
                box-shadow: 0 0 25px rgba(255,215,0,0.9);
                border-color: rgba(255,215,0,1);
            }
        }

        /* NEW: Gesture Feedback */
        .card-display.gesture-active {
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        }

        .card-display.king-auto {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 20px rgba(255,215,0,0.8) !important;
            animation: king-reveal 2s ease-out;
        }

        @keyframes king-reveal {
            0% { 
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 5px rgba(255,215,0,0.3);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                box-shadow: 0 0 30px rgba(255,215,0,1);
            }
            100% { 
                transform: scale(1.02) rotate(0deg);
                box-shadow: 0 0 15px rgba(255,215,0,0.6);
            }
        }

        /* Card content styling */
        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card-value {
            font-size: 1.1rem;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 2px;
        }

        .card-suit {
            font-size: 1.3rem;
            line-height: 1;
        }

        .action-button {
            width: 100%;
            padding: 6px 8px;
            background: #00a8ff;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 5px;
        }

        .action-button:hover {
            background: #0097e6;
            transform: translateY(-1px);
        }

        .action-button:disabled {
            background: rgba(255,255,255,0.3);
            cursor: not-allowed;
            transform: none;
        }

        .action-button.trade {
            background: #e74c3c;
        }

        .action-button.trade:hover {
            background: #c0392b;
        }

        .remove-button {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: rgba(255,0,0,0.8);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            display: none;
        }

        .focus-slot.custom .remove-button {
            display: block;
        }

        /* Available Players Bar */
        .available-players {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .available-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
            opacity: 0.8;
        }

        .players-scroll {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            padding: 5px 0;
            scrollbar-width: thin;
        }

        .players-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .players-scroll::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }

        .players-scroll::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .available-player {
            min-width: 80px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            position: relative;
            flex-shrink: 0;
        }

        .available-player:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .available-player.focused {
            border-color: #00FF00;
            background: rgba(0,255,0,0.1);
        }

        .available-player.current-turn {
            border-color: #00FF00;
            box-shadow: 0 0 8px rgba(0,255,0,0.4);
        }

        .available-player.dealer {
            border-color: #FFD700;
            background: rgba(255,215,0,0.1);
        }

        .available-player.tradeable {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            animation: tradeGlow 2s infinite;
        }

        @keyframes tradeGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(231, 76, 60, 0.3); }
            50% { box-shadow: 0 0 15px rgba(231, 76, 60, 0.6); }
        }

        .available-player .check-mark {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #00FF00;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .available-player .player-name {
            font-size: 0.7rem;
            margin-bottom: 3px;
            font-weight: bold;
        }

        /* Mini Cards - Proper Proportions */
        .available-player .mini-card {
            width: 30px;
            height: 42px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid #ddd;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 0.6rem;
            font-weight: bold;
            margin: 2px auto;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .available-player .mini-card.face-down {
            background: linear-gradient(145deg, #1a237e, #303f9f);
            color: white;
            font-size: 0.7rem;
        }

        .available-player .mini-card.red {
            color: #d32f2f;
        }

        .available-player .mini-card.black {
            color: #212121;
        }

        .available-player .mini-lives {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.8);
        }

        /* Game Controls */
        .game-controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .control-button {
            padding: 12px 8px;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }

        .control-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .control-button:disabled {
            background: rgba(255,255,255,0.3);
            cursor: not-allowed;
            transform: none;
        }

        .control-button.danger {
            background: #e74c3c;
        }

        .control-button.warning {
            background: #f39c12;
        }

        .control-button.primary {
            background: #3498db;
        }

        /* Chat and Game Log */
        .bottom-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .chat-section, .game-log {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            display: flex;
            flex-direction: column;
        }

        .section-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
            opacity: 0.8;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 5px;
            background: rgba(0,0,0,0.2);
            font-size: 0.7rem;
            margin-bottom: 8px;
            scrollbar-width: thin;
        }

        .messages::-webkit-scrollbar {
            width: 4px;
        }

        .messages::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
        }

        .messages::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .chat-input {
            display: flex;
            gap: 5px;
        }

        .chat-input input {
            flex: 1;
            padding: 6px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 0.8rem;
        }

        .chat-input input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .chat-input button {
            padding: 6px 12px;
            background: #3498db;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Menu Screens */
        .menu-screen {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            margin: 0 auto;
        }

        .menu-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #3498db;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .input-group {
            margin: 15px 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        /* Loading and Status */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.1rem;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 480px) {
            .focus-grid {
                grid-template-columns: 1fr 0.7fr 1fr;
                gap: 6px;
            }
            
            .focus-slot {
                min-height: 120px;
                padding: 6px;
            }
            
            .video-container {
                height: 50px;
            }

            .video-section {
                width: 60px;
            }
            
            .game-controls {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }
            
            .control-button {
                padding: 8px 4px;
                font-size: 0.7rem;
            }
            
            .bottom-section {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .game-status {
                font-size: 0.8rem;
            }

            .card-display {
                width: 60px;
                height: 85px;
                font-size: 0.8rem;
            }

            .available-player .mini-card {
                width: 25px;
                height: 35px;
                font-size: 0.5rem;
            }
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success { border-left: 4px solid #27ae60; }
        .toast.error { border-left: 4px solid #e74c3c; }
        .toast.warning { border-left: 4px solid #f39c12; }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu" class="menu-screen">
        <h1>üé¥ Screw Your Neighbor</h1>
        <p>Personal Table Experience</p>
        
        <button class="menu-button" onclick="showQuickMatch()">‚ö° Quick Match</button>
        <button class="menu-button" onclick="showCreateGame()">üéÆ Create Private Game</button>
        <button class="menu-button" onclick="showJoinGame()">üéØ Join Game</button>
        
        <div class="input-group">
            <label for="playerName">Your Name:</label>
            <input type="text" id="playerName" placeholder="Enter your name" value="Player">
        </div>
    </div>

    <!-- Quick Match Screen -->
    <div id="quick-match" class="menu-screen hidden">
        <h2>‚ö° Quick Match</h2>
        <p>Finding available games...</p>
        <div class="loading">
            <div class="spinner"></div>
            <span>Searching for players...</span>
        </div>
        <button class="menu-button" onclick="showMainMenu()">‚Üê Back</button>
    </div>

    <!-- Create Game Screen -->
    <div id="create-game" class="menu-screen hidden">
        <h2>üéÆ Create Private Game</h2>
        
        <div class="input-group">
            <label for="startingLives">Starting Lives:</label>
            <select id="startingLives">
                <option value="3">3 Lives</option>
                <option value="5">5 Lives</option>
                <option value="7">7 Lives</option>
            </select>
        </div>
        
        <div class="input-group">
            <label for="deckCount">Number of Decks:</label>
            <select id="deckCount">
                <option value="1">1 Deck</option>
                <option value="2">2 Decks</option>
            </select>
        </div>
        
        <button class="menu-button" onclick="createPrivateGame()">Create Game</button>
        <button class="menu-button" onclick="showMainMenu()">‚Üê Back</button>
    </div>

    <!-- Join Game Screen -->
    <div id="join-game" class="menu-screen hidden">
        <h2>üéØ Join Game</h2>
        
        <div class="input-group">
            <label for="gameCode">Game Code:</label>
            <input type="text" id="gameCode" placeholder="Enter game code" style="text-transform: uppercase;">
        </div>
        
        <button class="menu-button" onclick="joinGame()">Join Game</button>
        <button class="menu-button" onclick="showMainMenu()">‚Üê Back</button>
    </div>

    <!-- Game Content -->
    <div id="gameContent" class="container hidden">
        <!-- Header -->
        <div class="header">
            <h1>üé¥ Screw Your Neighbor</h1>
            <div class="game-status">
                <span id="gameCodeDisplay">Game: <strong>LOADING</strong></span>
                <span id="playerCount">Players: <strong>0/0</strong></span>
                <span id="connectionStatus">üî¥ Connecting...</span>
            </div>
        </div>

        <!-- Personal Table -->
        <div class="personal-table">
            <div class="focus-grid" id="focusGrid">
                <!-- Focus slots will be populated by JavaScript -->
            </div>
        </div>

        <!-- Available Players Bar -->
        <div class="available-players">
            <div class="available-title">Available Players - Tap to Focus</div>
            <div class="players-scroll" id="playersScroll">
                <!-- Available players will be populated by JavaScript -->
            </div>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button class="control-button" id="flipCardBtn" onclick="handleFlipClick()" disabled>
                üé¥ Flip Card
            </button>
            <button class="control-button" id="keepCardBtn" onclick="handleKeepClick()" disabled>
                ‚úã Keep Card
            </button>
            <button class="control-button" id="tradeCardBtn" onclick="handleTradeClick()" disabled>
                üîÑ Trade Card
            </button>
            <button class="control-button warning" id="endRoundBtn" onclick="endRound()" disabled>
                ‚è∞ End Round
            </button>
            <button class="control-button danger" onclick="leaveGame()">
                üö™ Leave
            </button>
        </div>

        <!-- Start Game Button (for host) -->
        <div id="hostControls" class="game-controls hidden">
            <button class="control-button primary" id="startGameBtn" onclick="startGame()">
                üöÄ Start Game
            </button>
        </div>

        <!-- Bottom Section -->
        <div class="bottom-section">
            <div class="chat-section">
                <div class="section-title">üí¨ Chat</div>
                <div class="messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
                    <button onclick="sendChatMessage()">Send</button>
                </div>
            </div>
            <div class="game-log">
                <div class="section-title">üìã Game Log</div>
                <div class="messages" id="gameMessages"></div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.19.1.js"></script>
    
    <script>
        // Global variables
        let socket = null;
        let currentGame = null;
        let playerId = null;
        let playerName = '';
        
        // Personal Table state
        let focusedPlayers = null;
        
        // Video state
        let isVideoJoined = false;
        let agoraClient = null;
        let localVideoTrack = null;
        let localAudioTrack = null;
        let remoteUsers = {};
        let videoStates = {};

        // Production optimizations
        let updateTimeout = null;
        let lastGameState = null;

        // NEW: Gesture and King Logic State
        let playerCardLooks = {}; // Track who has looked at their card
        let gestureState = {
            startX: 0,
            startY: 0,
            startTime: 0,
            isTracking: false,
            element: null,
            lastTap: 0
        };

        // NEW: Nudge system
        let nudgeTimeouts = {};
        let nudgeIntervals = {};

        // Initialize clean focus state
        function initializeFocusState() {
            focusedPlayers = {
                leftNeighbor: null,
                currentTurn: null,
                rightNeighbor: null,
                custom1: null,
                custom2: null
            };
        }

        // NEW: Enhanced Gesture Detection System
        function initializeGestureHandlers(cardElement, targetPlayerId) {
            if (!cardElement) {
                log(`‚ùå No card element to initialize gestures for player ${targetPlayerId}`);
                return;
            }

            log(`üéØ Initializing gesture handlers for player ${targetPlayerId}`);

            // Touch events for mobile
            cardElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            cardElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            cardElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Mouse events for desktop
            cardElement.addEventListener('mousedown', handleMouseStart);
            cardElement.addEventListener('mousemove', handleMouseMove);
            cardElement.addEventListener('mouseup', handleMouseEnd);

            // Store player ID for gesture handling
            cardElement.dataset.playerId = targetPlayerId;
            
            log(`‚úÖ Gesture handlers set for player ${targetPlayerId}`);
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            startGesture(touch.clientX, touch.clientY, e.target);
            log(`üì± Touch start: ${touch.clientX}, ${touch.clientY}`);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!gestureState.isTracking) return;
            const touch = e.touches[0];
            updateGesture(touch.clientX, touch.clientY);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            log(`üì± Touch end`);
            endGesture();
        }

        function handleMouseStart(e) {
            startGesture(e.clientX, e.clientY, e.target);
            log(`üñ±Ô∏è Mouse start: ${e.clientX}, ${e.clientY}`);
        }

        function handleMouseMove(e) {
            if (!gestureState.isTracking) return;
            updateGesture(e.clientX, e.clientY);
        }

        function handleMouseEnd(e) {
            log(`üñ±Ô∏è Mouse end`);
            endGesture();
        }

        function startGesture(x, y, element) {
            gestureState.startX = x;
            gestureState.startY = y;
            gestureState.startTime = Date.now();
            gestureState.isTracking = true;
            gestureState.element = element;
            log(`üéØ Gesture started at ${x}, ${y}`);
        }

        function updateGesture(x, y) {
            if (!gestureState.isTracking) return;
            
            const deltaX = x - gestureState.startX;
            const deltaY = y - gestureState.startY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Visual feedback for swipe
            if (distance > 20) {
                const cardElement = gestureState.element.closest('.card-display');
                if (cardElement && deltaX > 50) {
                    cardElement.style.transform = `translateX(${Math.min(deltaX - 50, 30)}px) rotate(${Math.min((deltaX - 50) / 5, 10)}deg)`;
                    cardElement.style.opacity = '0.8';
                    log(`üëâ Swipe feedback: deltaX=${deltaX}`);
                }
            }
        }

        function endGesture() {
            if (!gestureState.isTracking) return;
            
            const duration = Date.now() - gestureState.startTime;
            const cardElement = gestureState.element.closest('.card-display');
            
            log(`üéØ Gesture ended, duration: ${duration}ms`);
            
            if (cardElement) {
                // Check for swipe based on transform applied during updateGesture
                const transform = cardElement.style.transform || '';
                const wasSwipeRight = transform.includes('translateX') && !transform.includes('-');
                
                // Reset visual feedback
                cardElement.style.transform = '';
                cardElement.style.opacity = '';
                
                // Get the player ID from the card element's dataset
                const targetPlayerId = cardElement.dataset.playerId;
                log(`üéØ Target player ID: ${targetPlayerId}`);
                
                if (!targetPlayerId) {
                    log(`‚ùå No target player ID found in card element`);
                    gestureState.isTracking = false;
                    gestureState.element = null;
                    return;
                }
                
                if (wasSwipeRight) {
                    // Swipe right detected
                    log(`üëâ Swipe right detected for player ${targetPlayerId}`);
                    handleSwipeRight(targetPlayerId);
                } else if (duration < 300) {
                    // Quick tap
                    if (gestureState.lastTap && Date.now() - gestureState.lastTap < 500) {
                        // Double tap - Keep card
                        log(`üëÜüëÜ Double tap detected for player ${targetPlayerId}`);
                        handleDoubleTap(targetPlayerId);
                        gestureState.lastTap = 0;
                    } else {
                        // Single tap - Look at card
                        log(`üëÜ Single tap detected for player ${targetPlayerId}`);
                        gestureState.lastTap = Date.now();
                        handleSingleTap(targetPlayerId);
                    }
                }
            } else {
                log(`‚ùå No card element found for gesture`);
            }
            
            // Reset gesture state
            gestureState.isTracking = false;
            gestureState.element = null;
        }

        function handleSwipeRight(targetPlayerId) {
            log(`üëâ Swipe feedback: Swipe right for player ${targetPlayerId}`);
            if (targetPlayerId === playerId) {
                // Check if we can trade
                if (canPerformTrade()) {
                    const nextPlayer = getNextTradeablePlayer();
                    if (nextPlayer) {
                        log(`üîÑ Trading with ${nextPlayer.name}`);
                        requestTrade(nextPlayer.id);
                    } else {
                        log(`‚ùå No valid trade target found`);
                        showToast('No valid trade target!', 'warning');
                    }
                } else {
                    log(`‚ùå Cannot trade right now`);
                    showToast('Cannot trade right now!', 'warning');
                }
            }
        }

        function handleDoubleTap(targetPlayerId) {
            log(`‚úÖ Double tap: Processing for player ${targetPlayerId}`);
            if (targetPlayerId === playerId) {
                if (currentGame?.currentPlayerId === targetPlayerId) {
                    log(`‚úÖ Double tap: It's my turn, keeping card`);
                    keepCard();
                } else {
                    log(`‚ùå Double tap: Not my turn`);
                    showToast('Not your turn!', 'warning');
                }
            }
        }

        function handleSingleTap(targetPlayerId) {
            log(`üëÜ Single tap: Processing for player ${targetPlayerId}`);
            if (targetPlayerId === playerId) {
                const myPlayer = currentGame?.players?.find(p => p.id === targetPlayerId);
                if (myPlayer && myPlayer.hasCard && !playerCardLooks[targetPlayerId]) {
                    log(`üëÅÔ∏è Single tap: Flipping card for first look`);
                    flipCard();
                    markPlayerAsLooked(targetPlayerId);
                } else {
                    log(`üëÅÔ∏è Single tap: Player already looked or no card`);
                }
            }
        }

        // NEW: King Logic Functions
        function isKing(card) {
            return card && (card.value === 'K' || card.value === 'King');
        }

        function isJack(card) {
            return card && (card.value === 'J' || card.value === 'Jack');
        }

        function shouldAutoRevealKing(player) {
            return player && player.card && isKing(player.card) && !player.cardRevealed;
        }

        function handleKingAutoReveal(player) {
            if (shouldAutoRevealKing(player)) {
                log(`üëë AUTO-REVEALING King for ${player.name}`);
                if (player.id === playerId) {
                    // Auto-flip our own King
                    socket?.emit('flip-card', { gameId: currentGame.id });
                }
                markPlayerAsLooked(player.id);
                showToast(`${player.name} has a King! üëë`, 'warning');
            }
        }

        function canPerformTrade() {
            const isMyTurn = currentGame?.currentPlayerId === playerId;
            const gameStarted = currentGame?.state === 'playing';
            const tradingPhase = currentGame?.turnPhase === 'trading';
            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            
            log(`üîç Trade check: myTurn=${isMyTurn}, gameStarted=${gameStarted}, tradingPhase=${tradingPhase}`);
            
            // Can't trade if I have a King
            if (myPlayer?.card && isKing(myPlayer.card)) {
                log(`üëë Cannot trade: I have a King`);
                showToast('Kings cannot be traded! üëë', 'warning');
                return false;
            }
            
            const canTrade = isMyTurn && gameStarted && tradingPhase;
            log(`üîç Final trade result: ${canTrade}`);
            return canTrade;
        }

        function getNextTradeablePlayer() {
            if (!currentGame?.players) return null;
            
            const myIndex = currentGame.players.findIndex(p => p.id === playerId);
            if (myIndex === -1) return null;
            
            const playerCount = currentGame.players.length;
            let nextIndex = (myIndex + 1) % playerCount;
            let searchCount = 0;
            
            // Find next player who doesn't have a revealed King
            while (searchCount < playerCount) {
                const nextPlayer = currentGame.players[nextIndex];
                
                // Skip if player has revealed King (pass-through logic)
                if (nextPlayer.card && isKing(nextPlayer.card) && nextPlayer.cardRevealed) {
                    log(`üëë Passing through ${nextPlayer.name} (has revealed King)`);
                    nextIndex = (nextIndex + 1) % playerCount;
                    searchCount++;
                    continue;
                }
                
                // Valid trade target
                if (nextPlayer.lives > 0 && nextPlayer.id !== playerId) {
                    return nextPlayer;
                }
                
                nextIndex = (nextIndex + 1) % playerCount;
                searchCount++;
            }
            
            return null;
        }

        // NEW: Card Look Tracking
        function markPlayerAsLooked(playerId) {
            playerCardLooks[playerId] = true;
            log(`üëÅÔ∏è Player ${playerId} has looked at their card`);
            clearNudge(playerId);
        }

        function hasPlayerLooked(playerId) {
            return Boolean(playerCardLooks[playerId]);
        }

        function resetCardLooks() {
            playerCardLooks = {};
            log('üîÑ Reset all card look tracking');
        }

        // NEW: Nudge System
        function startNudge(playerId, reason = 'Look at your card') {
            clearNudge(playerId); // Clear any existing nudge
            
            const playerElement = document.querySelector(`[data-player-id="${playerId}"]`)?.closest('.focus-slot');
            if (!playerElement) return;
            
            const cardElement = playerElement.querySelector('.card-display');
            if (!cardElement) return;
            
            log(`üîî Starting nudge for player ${playerId}: ${reason}`);
            
            // Visual nudge - shake animation
            cardElement.classList.add('nudge-shake');
            
            // Audio nudge (optional)
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmoeAzeI1PKscBkFl3bvuKJcHA==');
                audio.volume = 0.3;
                audio.play().catch(() => {}); // Ignore audio errors
            } catch (error) {
                // Ignore audio errors
            }
            
            // Pulse effect
            nudgeIntervals[playerId] = setInterval(() => {
                if (cardElement.classList.contains('nudge-pulse')) {
                    cardElement.classList.remove('nudge-pulse');
                } else {
                    cardElement.classList.add('nudge-pulse');
                }
            }, 1000);
            
            // Auto-clear after 10 seconds
            nudgeTimeouts[playerId] = setTimeout(() => {
                clearNudge(playerId);
            }, 10000);
            
            // Show toast
            showToast(`${reason} üëÜ`, 'warning');
        }

        function clearNudge(playerId) {
            const playerElement = document.querySelector(`[data-player-id="${playerId}"]`)?.closest('.focus-slot');
            if (playerElement) {
                const cardElement = playerElement.querySelector('.card-display');
                if (cardElement) {
                    cardElement.classList.remove('nudge-shake', 'nudge-pulse');
                }
            }
            
            if (nudgeTimeouts[playerId]) {
                clearTimeout(nudgeTimeouts[playerId]);
                delete nudgeTimeouts[playerId];
            }
            
            if (nudgeIntervals[playerId]) {
                clearInterval(nudgeIntervals[playerId]);
                delete nudgeIntervals[playerId];
            }
        }

        function clearAllNudges() {
            Object.keys(nudgeTimeouts).forEach(playerId => clearNudge(playerId));
        }

        // Utility functions
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage);
            addGameMessage(message);
        }

        function addGameMessage(message) {
            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages) {
                const messageDiv = document.createElement('div');
                messageDiv.textContent = message;
                gameMessages.appendChild(messageDiv);
                gameMessages.scrollTop = gameMessages.scrollHeight;
                
                while (gameMessages.children.length > 100) {
                    gameMessages.removeChild(gameMessages.firstChild);
                }
            }
        }

        function addChatMessage(playerName, message) {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = `<strong>${playerName}:</strong> ${message}`;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                while (chatMessages.children.length > 50) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }

        // Complete cleanup function
        function completeCleanup() {
            log('üßπ Performing complete cleanup...');
            
            // 1. Disconnect socket completely
            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
                socket = null;
            }
            
            // 2. Clear ALL game state
            currentGame = null;
            playerId = null;
            lastGameState = null;
            
            // 3. Reinitialize focus state completely
            initializeFocusState();
            
            // 4. Clear video state
            videoStates = {};
            remoteUsers = {};
            isVideoJoined = false;
            
            // 5. Clear gesture and King logic state
            playerCardLooks = {};
            gestureState = {
                startX: 0,
                startY: 0,
                startTime: 0,
                isTracking: false,
                element: null,
                lastTap: 0
            };
            clearAllNudges();
            
            // 6. Clear all UI elements
            const focusGrid = document.getElementById('focusGrid');
            if (focusGrid) focusGrid.innerHTML = '';
            
            const playersScroll = document.getElementById('playersScroll');
            if (playersScroll) playersScroll.innerHTML = '';
            
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) chatMessages.innerHTML = '';
            
            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages) gameMessages.innerHTML = '';
            
            // 7. Reset connection status
            const connectionStatus = document.getElementById('connectionStatus');
            if (connectionStatus) connectionStatus.innerHTML = 'üî¥ Disconnected';
            
            // 8. Clear any timeouts
            if (updateTimeout) {
                clearTimeout(updateTimeout);
                updateTimeout = null;
            }
            
            log('üßπ Complete cleanup finished');
        }

        // Menu navigation
        function showMainMenu() {
            completeCleanup();
            document.querySelectorAll('.menu-screen, #gameContent').forEach(el => el.classList.add('hidden'));
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function showQuickMatch() {
            completeCleanup();
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('quick-match').classList.remove('hidden');
            
            setTimeout(() => {
                connectToServer();
                setTimeout(() => {
                    createPublicGame();
                }, 1000);
            }, 100);
        }

        function showCreateGame() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('create-game').classList.remove('hidden');
        }

        function showJoinGame() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('join-game').classList.remove('hidden');
        }

        function showGameContent() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('gameContent').classList.remove('hidden');
        }

        // Server connection
        function connectToServer() {
            log('üîÑ Creating FRESH server connection...');
            
            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
                socket = null;
            }
            
            socket = io({
                transports: ['websocket', 'polling'],
                timeout: 20000,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5,
                maxReconnectionAttempts: 10,
                forceNew: true
            });
            
            socket.on('connect', () => {
                log('‚úÖ FRESH connection established! ID: ' + socket.id);
                document.getElementById('connectionStatus').innerHTML = 'üü¢ Connected';
                
                playerName = document.getElementById('playerName').value || 'Player';
                playerId = socket.id;
            });

            socket.on('disconnect', (reason) => {
                log(`‚ùå Disconnected: ${reason}`);
                document.getElementById('connectionStatus').innerHTML = 'üî¥ Disconnected';
                
                if (isVideoJoined) {
                    leaveVideoCall().catch(console.error);
                }
            });

            socket.on('connect_error', (error) => {
                log(`‚ùå Connection error: ${error.message}`);
                showToast('Connection failed. Retrying...', 'error');
            });

            setupSocketEvents();
        }

        // Socket event handlers
        function setupSocketEvents() {
            socket.on('public-game-created', function(data) {
                log('üéÆ FRESH public game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();
            });

            socket.on('private-game-created', function(data) {
                log('üéÆ FRESH private game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();
                
                if (data.friendCode) {
                    showToast(`Game Code: ${data.friendCode}`, 'success');
                }
            });

            socket.on('game-created', function(data) {
                log('üéÆ FRESH game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();
                
                if (data.friendCode) {
                    showToast(`Game Code: ${data.friendCode}`, 'success');
                }
            });

            socket.on('game-joined', function(data) {
                log('üéÆ Joined game! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                
                if (currentGame.hostId === playerId) {
                    showHostControls();
                }
            });

            socket.on('player-joined', function(data) {
                log(`üëã Player joined: ${data.newPlayer?.name || 'Unknown'}`);
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('game-started', function(data) {
                log('üéÆ Game started!');
                currentGame = data.game;
                
                resetCardLooks();
                clearAllNudges();
                
                hideHostControls();
                updateGameDisplay();
                updatePersonalTable();
                
                setTimeout(() => {
                    initializeVideoCall();
                }, 1000);
            });

            socket.on('round-started', function(data) {
                log(`üîÑ New round started!`);
                currentGame = data.game;
                
                resetCardLooks();
                clearAllNudges();
                
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('cards-dealt', function(data) {
                log('üé¥ Cards dealt!');
                currentGame = data.game;
                
                resetCardLooks();
                clearAllNudges();
                
                // Check for any Kings that should auto-reveal
                if (currentGame.players) {
                    currentGame.players.forEach(player => {
                        if (shouldAutoRevealKing(player)) {
                            setTimeout(() => handleKingAutoReveal(player), 500);
                        }
                    });
                }
                
                updateGameDisplay();
                updatePersonalTable();
                
                // Start nudging players who haven't looked at their cards
                setTimeout(() => {
                    if (currentGame.players) {
                        currentGame.players.forEach(player => {
                            if (player.hasCard && !hasPlayerLooked(player.id) && player.id !== playerId) {
                                startNudge(player.id, `${player.name} should look at their card`);
                            }
                        });
                    }
                }, 3000);
            });

            socket.on('trade-completed', function(data) {
                const result = data.result;
                if (result.tradedWithDeck) {
                    log('üé¥ SPECIAL RULE: Dealer had King - traded with deck instead!');
                } else if (result.traded) {
                    log('‚úÖ Cards swapped successfully!');
                    
                    // Both players have now "looked" at their new cards
                    if (result.fromPlayerId) markPlayerAsLooked(result.fromPlayerId);
                    if (result.toPlayerId) markPlayerAsLooked(result.toPlayerId);
                    
                } else if (result.blocked) {
                    log('üö´ Trade BLOCKED by Jack - "Screw You!"');
                } else if (result.kingRevealed) {
                    if (result.roundEnded) {
                        log('üëë King revealed but Jack blocks pass-through - Round ends!');
                    } else {
                        log('üëë King revealed - can pass to next player!');
                    }
                }
                currentGame = data.game;
                
                // Check for new Kings that should auto-reveal
                if (currentGame.players) {
                    currentGame.players.forEach(player => {
                        if (shouldAutoRevealKing(player)) {
                            handleKingAutoReveal(player);
                        }
                    });
                }
                
                updateGameDisplay();
                updatePersonalTable();
                showToast('Trade completed!', 'success');
            });

            socket.on('turn-skipped', function(data) {
                const action = data.result.wasKing ? 'kept their King' : 'kept their card';
                log(`‚è≠Ô∏è Player ${data.playerId} ${action} and ended turn`);
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('card-flipped', function(data) {
                log(`üé¥ Player ${data.playerId} flipped their card`);
                currentGame = data.game;
                
                markPlayerAsLooked(data.playerId);
                
                // Check if this revealed a King
                const player = currentGame.players?.find(p => p.id === data.playerId);
                if (player && shouldAutoRevealKing(player)) {
                    handleKingAutoReveal(player);
                }
                
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('dealer-traded-deck', function(data) {
                log('üé¥ Dealer traded with deck');
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('dealer-skipped-trade', function(data) {
                log('üé¥ Dealer kept their card');
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('round-ended', function(data) {
                log(`üèÅ Round ${data.result?.round || ''} ended`);
                currentGame = data.game;
                
                resetCardLooks();
                clearAllNudges();
                
                updateGameDisplay();
                updatePersonalTable();
                
                if (data.result?.losers) {
                    const losers = data.result.losers.map(l => l.name).join(', ');
                    showToast(`Losers: ${losers}`, 'warning');
                }
            });

            socket.on('game-finished', function(data) {
                log(`üéâ Game finished!`);
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
                
                if (data.winner) {
                    showToast(`Winner: ${data.winner.name}!`, 'success');
                }
                
                setTimeout(() => {
                    leaveVideoCall().catch(console.error);
                }, 5000);
            });

            socket.on('chat-message', function(data) {
                addChatMessage(data.playerName || 'Unknown', data.message);
            });

            socket.on('error', function(data) {
                log(`‚ùå Error: ${data.message}`);
                showToast(data.message, 'error');
            });
        }

        // Game creation
        function createPublicGame() {
            if (!socket || !socket.connected) {
                log('‚ùå No socket connection - reconnecting...');
                connectToServer();
                setTimeout(createPublicGame, 1000);
                return;
            }

            playerName = document.getElementById('playerName').value.trim() || 'Player';
            
            log(`üéÆ Creating FRESH public game for ${playerName} (${socket.id})`);

            socket.emit('quick-match', {
                playerName: playerName,
                userId: socket.id,
                token: `demo_token_${socket.id}`
            });
        }

        function createPrivateGame() {
            if (!socket) {
                connectToServer();
                setTimeout(createPrivateGame, 1000);
                return;
            }

            playerName = document.getElementById('playerName').value.trim() || 'Player';

            const settings = {
                startingLives: parseInt(document.getElementById('startingLives').value),
                deckCount: parseInt(document.getElementById('deckCount').value),
                tournamentMode: 'single',
                cardStyle: 'classic'
            };

            socket.emit('create-private-game', {
                playerName: playerName,
                userId: socket.id,
                token: `demo_token_${socket.id}`,
                settings: settings
            });
        }

        function joinGame() {
            const gameCode = document.getElementById('gameCode').value.trim().toUpperCase();
            if (!gameCode) {
                showToast('Please enter a game code', 'error');
                return;
            }

            if (!socket) {
                connectToServer();
                setTimeout(() => joinGame(), 1000);
                return;
            }

            playerName = document.getElementById('playerName').value.trim() || 'Player';

            socket.emit('join-game', {
                friendCode: gameCode,
                playerName: playerName,
                userId: socket.id,
                token: `demo_token_${socket.id}`
            });
        }

        // Game display updates
        function updateGameDisplay() {
            if (!currentGame) return;

            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }
            
            updateTimeout = setTimeout(() => {
                performGameDisplayUpdate();
            }, 50);
        }

        function performGameDisplayUpdate() {
            if (!currentGame) return;

            document.getElementById('gameCodeDisplay').innerHTML = `Game: <strong>${currentGame.gameCode || currentGame.id || 'UNKNOWN'}</strong>`;
            document.getElementById('playerCount').innerHTML = `Players: <strong>${currentGame.players?.length || 0}/${currentGame.maxPlayers || 8}</strong>`;

            updateButtonStates();
        }

        function updateButtonStates() {
            if (!currentGame) return;

            const myPlayer = currentGame.players?.find(p => p.id === playerId);
            const isMyTurn = currentGame.currentPlayerId === playerId;
            const gameStarted = currentGame.state === 'playing';
            const canEndRound = gameStarted && currentGame.turnPhase === 'revealing';
            const canTrade = canPerformTrade();

            // Main control buttons
            const flipBtn = document.getElementById('flipCardBtn');
            const keepBtn = document.getElementById('keepCardBtn');
            const tradeBtn = document.getElementById('tradeCardBtn');
            const endBtn = document.getElementById('endRoundBtn');

            if (flipBtn) {
                flipBtn.disabled = !gameStarted || !myPlayer || !myPlayer.hasCard;
                flipBtn.style.opacity = flipBtn.disabled ? '0.5' : '1';
            }
            if (keepBtn) {
                keepBtn.disabled = !isMyTurn || !gameStarted;
                keepBtn.style.opacity = keepBtn.disabled ? '0.5' : '1';
            }
            if (tradeBtn) {
                tradeBtn.disabled = !canTrade;
                tradeBtn.style.opacity = tradeBtn.disabled ? '0.5' : '1';
            }
            if (endBtn) {
                endBtn.disabled = !canEndRound;
                endBtn.style.opacity = endBtn.disabled ? '0.5' : '1';
            }

            // Update all card action buttons
            document.querySelectorAll('.action-button').forEach(btn => {
                if (btn.textContent.includes('Keep')) {
                    btn.disabled = !isMyTurn || !gameStarted;
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                }
                if (btn.textContent.includes('Trade')) {
                    btn.disabled = !canTrade;
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                }
            });

            log(`üîÑ Button states updated: myTurn=${isMyTurn}, gameStarted=${gameStarted}, phase=${currentGame.turnPhase}, canTrade=${canTrade}`);
        }

        function showHostControls() {
            if (currentGame?.hostId === playerId && currentGame?.state === 'waiting') {
                document.getElementById('hostControls')?.classList.remove('hidden');
            }
        }

        function hideHostControls() {
            document.getElementById('hostControls')?.classList.add('hidden');
        }

        // Personal Table management
        function updatePersonalTable() {
            if (!currentGame || !currentGame.players || !Array.isArray(currentGame.players)) return;
            if (!focusedPlayers) initializeFocusState();

            const myPlayerIndex = currentGame.players.findIndex(p => p.id === playerId);
            if (myPlayerIndex === -1) {
                log(`‚ùå Cannot find myself (${playerId}) in players list`);
                return;
            }

            const playerCount = currentGame.players.length;
            if (playerCount < 2) return;

            log(`üîÑ Updating personal table: ${playerCount} players, I am ${currentGame.players[myPlayerIndex].name} at index ${myPlayerIndex}`);

            if (playerCount <= 5) {
                autoFillAllPlayers(myPlayerIndex, playerCount);
                hideAvailablePlayersSection();
            } else {
                setupCustomFocusMode(myPlayerIndex, playerCount);
                showAvailablePlayersSection();
            }

            renderPersonalTable();
            renderAvailablePlayers();
        }

        function autoFillAllPlayers(myPlayerIndex, playerCount) {
            const players = currentGame.players;
            const myPlayer = players[myPlayerIndex];
            
            focusedPlayers.currentTurn = myPlayer;
            
            const leftNeighborIndex = (myPlayerIndex - 1 + playerCount) % playerCount;
            const rightNeighborIndex = (myPlayerIndex + 1) % playerCount;
            
            focusedPlayers.leftNeighbor = players[leftNeighborIndex];
            focusedPlayers.rightNeighbor = players[rightNeighborIndex];
            
            const remainingPlayers = players.filter((p, index) => 
                index !== myPlayerIndex && 
                index !== leftNeighborIndex && 
                index !== rightNeighborIndex
            );
            
            focusedPlayers.custom1 = remainingPlayers[0] || null;
            focusedPlayers.custom2 = remainingPlayers[1] || null;
            
            log(`üéØ Personal view for ${myPlayer.name}: Left=${players[leftNeighborIndex]?.name}, Center=${myPlayer.name}, Right=${players[rightNeighborIndex]?.name}`);
        }

        function setupCustomFocusMode(myPlayerIndex, playerCount) {
            const players = currentGame.players;
            const myPlayer = players[myPlayerIndex];
            
            focusedPlayers.currentTurn = myPlayer;
            
            const leftNeighborIndex = (myPlayerIndex - 1 + playerCount) % playerCount;
            const rightNeighborIndex = (myPlayerIndex + 1) % playerCount;
            
            focusedPlayers.leftNeighbor = players[leftNeighborIndex];
            focusedPlayers.rightNeighbor = players[rightNeighborIndex];
            
            if (focusedPlayers.custom1 && !players.find(p => p.id === focusedPlayers.custom1.id)) {
                focusedPlayers.custom1 = null;
            }
            if (focusedPlayers.custom2 && !players.find(p => p.id === focusedPlayers.custom2.id)) {
                focusedPlayers.custom2 = null;
            }
            
            const dealer = players.find(p => p.id === currentGame.dealerId);
            if (dealer && !isPlayerInFocus(dealer.id)) {
                if (!focusedPlayers.custom1) {
                    focusedPlayers.custom1 = dealer;
                } else if (!focusedPlayers.custom2) {
                    focusedPlayers.custom2 = dealer;
                }
            }
            
            log(`üéØ Personal view for ${myPlayer.name}: Left=${players[leftNeighborIndex]?.name}, Center=${myPlayer.name}, Right=${players[rightNeighborIndex]?.name}`);
        }

        function hideAvailablePlayersSection() {
            const availableSection = document.querySelector('.available-players');
            if (availableSection) {
                availableSection.style.display = 'none';
            }
        }

        function showAvailablePlayersSection() {
            const availableSection = document.querySelector('.available-players');
            if (availableSection) {
                availableSection.style.display = 'block';
            }
        }

        function isPlayerInFocus(playerId) {
            if (!focusedPlayers) return false;
            return Object.values(focusedPlayers).some(player => player && player.id === playerId);
        }

        function renderPersonalTable() {
            const focusGrid = document.getElementById('focusGrid');
            if (!focusGrid || !focusedPlayers) return;
            
            focusGrid.innerHTML = '';

            const leftSlot = createFocusSlot('slot', focusedPlayers.leftNeighbor, false);
            leftSlot.style.gridColumn = '1';
            leftSlot.style.gridRow = '1';
            focusGrid.appendChild(leftSlot);

            const centerSlot = createFocusSlot('slot', focusedPlayers.currentTurn, false);
            centerSlot.style.gridColumn = '2';
            centerSlot.style.gridRow = '1';
            focusGrid.appendChild(centerSlot);

            const rightSlot = createFocusSlot('slot', focusedPlayers.rightNeighbor, false);
            rightSlot.style.gridColumn = '3';
            rightSlot.style.gridRow = '1';
            focusGrid.appendChild(rightSlot);

            const custom1Slot = createFocusSlot('custom', focusedPlayers.custom1, true);
            custom1Slot.style.gridColumn = '1';
            custom1Slot.style.gridRow = '2';
            focusGrid.appendChild(custom1Slot);

            const custom2Slot = createFocusSlot('custom', focusedPlayers.custom2, true);
            custom2Slot.style.gridColumn = '3';
            custom2Slot.style.gridRow = '2';
            focusGrid.appendChild(custom2Slot);
        }

        function createFocusSlot(type, player, removable) {
            const slot = document.createElement('div');
            let slotClasses = `focus-slot ${type}`;
            
            if (player && player.id === currentGame?.currentPlayerId) {
                slotClasses += ' current-turn';
            }
            
            if (player && player.id === currentGame?.dealerId) {
                slotClasses += ' dealer';
            }
            
            slot.className = slotClasses;

            if (!player) {
                slot.classList.add('empty');
                slot.innerHTML = `
                    <div class="add-icon">+</div>
                    <div>Tap player below</div>
                `;
                return slot;
            }

            const playerContent = document.createElement('div');
            playerContent.className = 'player-content';

            const cardSection = document.createElement('div');
            cardSection.className = 'card-section';

            const playerInfo = document.createElement('div');
            playerInfo.className = 'player-info';
            const dealerText = (player.id === currentGame?.dealerId) ? ' (Dealer)' : '';
            playerInfo.innerHTML = `
                <span class="player-name">${player.name}${dealerText}</span>
                <span class="player-lives">‚ù§Ô∏è ${player.lives || 3}</span>
            `;

            const cardDisplay = document.createElement('div');
            cardDisplay.className = 'card-display';
            
            // FIXED: Card visibility logic - only show other players' cards during revealing phase
            const shouldShowCard = shouldPlayerCardBeVisible(player);
            
            if (player.id === playerId) {
                log(`üé¥ My card state: hasCard=${player.hasCard}, card=${player.card ? `${player.card.value}${player.card.suit}` : 'null'}, revealed=${player.cardRevealed}, shouldShow=${shouldShowCard}`);
            }
            
            if (shouldAutoRevealKing(player)) {
                handleKingAutoReveal(player);
            }
            
            if (player.card && shouldShowCard) {
                const card = player.card;
                const isRed = card.suit === '‚ô•' || card.suit === '‚ô¶';
                let cardClasses = isRed ? ' red revealed' : ' black revealed';
                
                if (isKing(card)) {
                    cardClasses += ' king-auto';
                }
                
                cardDisplay.className += cardClasses;
                
                const cardContent = document.createElement('div');
                cardContent.className = 'card-content';
                cardContent.innerHTML = `
                    <div class="card-value">${card.value}</div>
                    <div class="card-suit">${card.suit}</div>
                `;
                cardDisplay.appendChild(cardContent);
            } else if (player.hasCard || player.card) {
                cardDisplay.className += ' face-down';
                cardDisplay.textContent = 'üÇ†';
                
                // Only add gesture handlers for my own card
                if (player.id === playerId) {
                    setTimeout(() => {
                        initializeGestureHandlers(cardDisplay, player.id);
                    }, 100);
                }
                
                if (player.id !== playerId && !hasPlayerLooked(player.id) && player.hasCard) {
                    setTimeout(() => {
                        if (!hasPlayerLooked(player.id)) {
                            startNudge(player.id, `${player.name} should look at their card`);
                        }
                    }, 2000);
                }
            } else {
                cardDisplay.textContent = 'No Card';
            }

            cardSection.appendChild(playerInfo);
            cardSection.appendChild(cardDisplay);
            cardSection.setAttribute('data-player-id', player.id);

            // Add action buttons for my own card
            if (player.id === playerId) {
                const actionContainer = document.createElement('div');
                actionContainer.style.display = 'flex';
                actionContainer.style.gap = '4px';
                actionContainer.style.marginTop = '4px';

                // Keep Card button
                const keepBtn = document.createElement('button');
                keepBtn.className = 'action-button';
                keepBtn.textContent = '‚úã Keep';
                keepBtn.style.fontSize = '0.6rem';
                keepBtn.style.padding = '4px 6px';
                keepBtn.disabled = currentGame?.currentPlayerId !== playerId;
                keepBtn.onclick = () => {
                    log(`‚úã Keep button clicked`);
                    keepCard();
                };
                actionContainer.appendChild(keepBtn);

                // Trade button
                const tradeBtn = document.createElement('button');
                tradeBtn.className = 'action-button trade';
                tradeBtn.textContent = 'üîÑ Trade';
                tradeBtn.style.fontSize = '0.6rem';
                tradeBtn.style.padding = '4px 6px';
                tradeBtn.disabled = !canPerformTrade();
                tradeBtn.onclick = () => {
                    log(`üîÑ Trade button clicked`);
                    const nextPlayer = getNextTradeablePlayer();
                    if (nextPlayer) {
                        requestTrade(nextPlayer.id);
                    } else {
                        showToast('No valid trade target!', 'warning');
                    }
                };
                actionContainer.appendChild(tradeBtn);

                cardSection.appendChild(actionContainer);
            }

            // Add trade button for other players I can trade with
            if (player.id !== playerId && canTradeWith(player)) {
                const actionBtn = document.createElement('button');
                actionBtn.className = 'action-button trade';
                actionBtn.textContent = 'Trade ‚Üí';
                actionBtn.onclick = () => {
                    log(`üîÑ Trading with ${player.name}`);
                    requestTrade(player.id);
                };
                cardSection.appendChild(actionBtn);
            }

            const videoSection = document.createElement('div');
            videoSection.className = 'video-section';

            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';
            const videoElement = document.createElement('div');
            videoElement.className = 'video-element';
            videoElement.id = `video-${player.id}`;
            
            const placeholder = document.createElement('div');
            placeholder.className = 'video-placeholder';
            placeholder.textContent = 'üìπ';
            videoElement.appendChild(placeholder);
            
            const videoControls = document.createElement('div');
            videoControls.className = 'video-controls';
            videoControls.innerHTML = `
                <button class="video-control-btn" onclick="startVideoForPlayer('${player.id}')" title="Start Video">üì∑</button>
                <button class="video-control-btn" onclick="toggleMuteForPlayer('${player.id}')" title="Mute">üé§</button>
                <button class="video-control-btn" onclick="endVideoForPlayer('${player.id}')" title="End">‚ùå</button>
            `;
            
            videoContainer.appendChild(videoElement);
            videoContainer.appendChild(videoControls);
            videoSection.appendChild(videoContainer);

            playerContent.appendChild(cardSection);
            playerContent.appendChild(videoSection);
            slot.appendChild(playerContent);

            if (removable) {
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-button';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeFromFocus(player.id);
                };
                slot.appendChild(removeBtn);
            }

            return slot;
        }

        // FIXED: Card visibility function - only show other players' cards during revealing phase
        function shouldPlayerCardBeVisible(player) {
            // Always show your own card
            if (player.id === playerId) {
                return true;
            }
            
            // Only show other players' cards during the revealing phase at the end of the round
            if (currentGame.turnPhase === 'revealing') {
                return true;
            }
            
            // Don't show other players' cards during normal gameplay, even if they've looked at them
            return false;
        }

        function canTradeWith(player) {
            if (!currentGame) return false;
            
            const isMyTurn = currentGame.currentPlayerId === playerId;
            const gameStarted = currentGame.state === 'playing';
            const tradingPhase = currentGame.turnPhase === 'trading';
            
            if (!isMyTurn || !gameStarted || !tradingPhase || player.lives <= 0) {
                return false;
            }
            
            const myPlayer = currentGame.players.find(p => p.id === playerId);
            if (myPlayer?.card && isKing(myPlayer.card)) {
                return false;
            }
            
            const nextTradeablePlayer = getNextTradeablePlayer();
            const canTrade = nextTradeablePlayer && player.id === nextTradeablePlayer.id;
            
            if (canTrade) {
                log(`üîÑ ${player.name} is valid trade target`);
            }
            
            return canTrade;
        }

        function renderAvailablePlayers() {
            const playersScroll = document.getElementById('playersScroll');
            if (!playersScroll) return;
            
            playersScroll.innerHTML = '';

            if (!currentGame || !currentGame.players) return;

            const playerCount = currentGame.players.length;
            if (playerCount <= 5) {
                return;
            }

            const addedPlayerIds = new Set();
            const playersNotInFocus = currentGame.players.filter(player => {
                return !isPlayerInFocus(player.id);
            });

            playersNotInFocus.forEach(player => {
                if (addedPlayerIds.has(player.id)) {
                    return;
                }
                addedPlayerIds.add(player.id);

                const playerDiv = document.createElement('div');
                let playerClasses = 'available-player';
                
                if (player.id === currentGame.currentPlayerId) {
                    playerClasses += ' current-turn';
                }
                
                if (player.id === currentGame.dealerId) {
                    playerClasses += ' dealer';
                }
                
                if (canTradeWith(player)) {
                    playerClasses += ' tradeable';
                }
                
                playerDiv.className = playerClasses;

                const playerNameDiv = document.createElement('div');
                playerNameDiv.className = 'player-name';
                playerNameDiv.textContent = player.name;
                playerDiv.appendChild(playerNameDiv);

                const miniCard = document.createElement('div');
                miniCard.className = 'mini-card';
                
                // FIXED: Use the same card visibility logic
                const shouldShowCard = shouldPlayerCardBeVisible(player);
                
                if (player.card && shouldShowCard) {
                    const isRed = player.card.suit === '‚ô•' || player.card.suit === '‚ô¶';
                    miniCard.className += isRed ? ' red' : ' black';
                    miniCard.textContent = `${player.card.value}${player.card.suit}`;
                } else if (player.hasCard || player.card) {
                    miniCard.className += ' face-down';
                    miniCard.textContent = 'üÇ†';
                } else {
                    miniCard.textContent = '‚Äî';
                }
                playerDiv.appendChild(miniCard);

                const miniLives = document.createElement('div');
                miniLives.className = 'mini-lives';
                miniLives.textContent = `‚ù§Ô∏è ${player.lives || 3}`;
                playerDiv.appendChild(miniLives);

                playerDiv.onclick = () => addToFocus(player);
                playersScroll.appendChild(playerDiv);
            });

            log(`‚úÖ Rendered ${addedPlayerIds.size} available players`);
        }

        function addToFocus(player) {
            if (!focusedPlayers) initializeFocusState();
            
            const playerCount = currentGame.players.length;
            
            if (playerCount <= 5) {
                log(`Auto-fill mode active - cannot manually add players`);
                return;
            }
            
            if (isPlayerInFocus(player.id)) {
                log(`Player ${player.name} already in focus`);
                return;
            }

            if (!focusedPlayers.custom1) {
                focusedPlayers.custom1 = player;
                log(`Added ${player.name} to custom1`);
            } else if (!focusedPlayers.custom2) {
                focusedPlayers.custom2 = player;
                log(`Added ${player.name} to custom2`);
            } else {
                focusedPlayers.custom1 = player;
                log(`Replaced custom1 with ${player.name}`);
            }

            renderPersonalTable();
            renderAvailablePlayers();
            
            setTimeout(() => {
                initializeVideoForPlayer(player.id);
            }, 100);
        }

        function removeFromFocus(playerId) {
            if (!focusedPlayers) return;
            
            const playerCount = currentGame.players.length;
            
            if (playerCount <= 5) {
                log(`Auto-fill mode active - cannot manually remove players`);
                return;
            }
            
            if (focusedPlayers.custom1 && focusedPlayers.custom1.id === playerId) {
                focusedPlayers.custom1 = null;
                log(`Removed player from custom1`);
            } else if (focusedPlayers.custom2 && focusedPlayers.custom2.id === playerId) {
                focusedPlayers.custom2 = null;
                log(`Removed player from custom2`);
            }

            renderPersonalTable();
            renderAvailablePlayers();
        }

        // Video Controls
        function startVideoForPlayer(playerId) {
            if (playerId === playerId) {
                initializeVideoCall();
            }
            showToast(`üìπ Video starting for player`, 'info');
        }

        function toggleMuteForPlayer(playerId) {
            if (playerId === playerId && localAudioTrack) {
                const enabled = localAudioTrack.enabled;
                localAudioTrack.setEnabled(!enabled);
                showToast(`üé§ ${enabled ? 'Muted' : 'Unmuted'}`, 'info');
                
                const btn = document.querySelector(`[onclick="toggleMuteForPlayer('${playerId}')"]`);
                if (btn) {
                    btn.className = enabled ? 'video-control-btn muted' : 'video-control-btn';
                    btn.textContent = enabled ? 'üîá' : 'üé§';
                }
            }
        }

        function endVideoForPlayer(playerId) {
            if (playerId === playerId) {
                leaveVideoCall();
            }
            showToast(`üìπ Video ended for player`, 'info');
        }

        // Enhanced Game action handlers
        function handleFlipClick() {
            log(`üé¥ Flip Card button clicked`);
            flipCard();
        }

        function handleKeepClick() {
            log(`‚úã Keep Card button clicked`);
            if (currentGame?.currentPlayerId !== playerId) {
                log(`‚ùå Not my turn! Current turn: ${currentGame?.currentPlayerId}, Me: ${playerId}`);
                showToast('Not your turn!', 'warning');
                return;
            }
            keepCard();
        }

        function handleTradeClick() {
            log(`üîÑ Trade Card button clicked`);
            if (!canPerformTrade()) {
                log(`‚ùå Cannot trade right now`);
                showToast('Cannot trade right now!', 'warning');
                return;
            }
            
            const nextPlayer = getNextTradeablePlayer();
            if (nextPlayer) {
                log(`üîÑ Trading with ${nextPlayer.name}`);
                requestTrade(nextPlayer.id);
            } else {
                log(`‚ùå No valid trade target`);
                showToast('No valid trade target!', 'warning');
            }
        }

        // Game actions
        function startGame() {
            if (!socket || !currentGame) {
                showToast('Game not ready', 'error');
                return;
            }
            
            if (currentGame.hostId !== playerId) {
                showToast('Only the host can start the game', 'error');
                return;
            }

            const settings = { startingLives: 3, deckCount: 1 };

            socket.emit('start-game', { 
                gameId: currentGame.id,
                settings 
            });
            log('üöÄ Starting game...');
        }

        function flipCard() {
            if (!socket || !currentGame) {
                log(`‚ùå Flip card failed: no socket or game`);
                return;
            }
            
            log(`üé¥ Flipping card for player ${playerId}`);
            socket.emit('flip-card', { gameId: currentGame.id });
            
            markPlayerAsLooked(playerId);
        }

        function keepCard() {
            if (!socket || !currentGame) {
                log(`‚ùå Keep card failed: no socket or game`);
                return;
            }
            
            // Check if it's actually my turn
            if (currentGame.currentPlayerId !== playerId) {
                log(`‚ùå Keep card failed: not my turn (current: ${currentGame.currentPlayerId}, me: ${playerId})`);
                showToast('Not your turn!', 'warning');
                return;
            }
            
            const myPlayer = currentGame.players?.find(p => p.id === playerId);
            if (myPlayer?.card && isKing(myPlayer.card)) {
                log('üëë Keeping King (automatic)');
                showToast('Keeping your King! üëë', 'success');
            } else {
                log('‚úã Keeping your card...');
            }
            
            socket.emit('skip-turn', { gameId: currentGame.id });
        }

        function requestTrade(targetPlayerId) {
            if (!socket || !currentGame) return;
            
            if (!canPerformTrade()) {
                log(`‚ùå Cannot perform trade right now`);
                return;
            }
            
            if (!hasPlayerLooked(targetPlayerId)) {
                const targetPlayer = currentGame.players.find(p => p.id === targetPlayerId);
                const targetName = targetPlayer?.name || 'Player';
                
                log(`üîî ${targetName} must look at their card first!`);
                showToast(`${targetName} must look at their card first! üëÜ`, 'warning');
                
                startNudge(targetPlayerId, `${targetName}, look at your card before trade!`);
                return;
            }
            
            log(`üîÑ Requesting trade: ${playerId} ‚Üí ${targetPlayerId}`);
            
            const myIndex = currentGame.players.findIndex(p => p.id === playerId);
            const targetIndex = currentGame.players.findIndex(p => p.id === targetPlayerId);
            const expectedNextIndex = (myIndex + 1) % currentGame.players.length;
            
            log(`üîç Trade Debug: My index: ${myIndex}, Target index: ${targetIndex}, Expected next: ${expectedNextIndex}`);
            log(`üîç Current turn: ${currentGame.currentPlayerId}, My turn: ${currentGame.currentPlayerId === playerId}`);
            
            socket.emit('trade-request', { 
                gameId: currentGame.id,
                targetPlayerId 
            });
        }

        function endRound() {
            if (!socket || !currentGame) return;
            socket.emit('end-round', { gameId: currentGame.id });
            log('‚è∞ Ending round...');
        }

        function leaveGame() {
            if (confirm('Are you sure you want to leave the game?')) {
                leaveVideoCall().catch(console.error);
                completeCleanup();
                showMainMenu();
                log('üö™ Left game and cleaned up completely');
            }
        }

        // Chat functions
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message && socket) {
                socket.emit('game-chat', { 
                    gameId: currentGame.id,
                    message 
                });
                chatInput.value = '';
            }
        }

        // Video integration (add your Agora token)
        function initializeVideoCall() {
            if (isVideoJoined) return;

            log('üìπ Initializing video call...');
            
            try {
                agoraClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
                log('üìπ Agora client created successfully');

                agoraClient.on("user-published", handleUserPublished);
                agoraClient.on("user-unpublished", handleUserUnpublished);
                agoraClient.on("user-left", handleUserLeft);
                log('üìπ Event listeners added');

                joinVideoChannel();
            } catch (error) {
                log(`‚ùå Error initializing video: ${error.message}`);
            }
        }

        async function joinVideoChannel() {
            try {
                const channelName = currentGame?.gameCode || currentGame?.id || 'test123';
                const uid = Math.floor(Math.random() * 1000000);
                const appId = 'YOUR_AGORA_APP_ID'; // Add your token here

                log(`üìπ Attempting to join channel: ${channelName}`);

                await agoraClient.join(appId, channelName, null, uid);
                log('üìπ Successfully joined channel');

                try {
                    localVideoTrack = await AgoraRTC.createCameraVideoTrack();
                    localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                    log('üìπ Media tracks created');

                    const myVideoElement = document.getElementById(`video-${playerId}`);
                    if (myVideoElement && localVideoTrack) {
                        localVideoTrack.play(myVideoElement);
                        const placeholder = myVideoElement.querySelector('.video-placeholder');
                        if (placeholder) placeholder.remove();
                    }

                    await agoraClient.publish([localVideoTrack, localAudioTrack]);
                    log('üìπ Tracks published successfully');

                    isVideoJoined = true;
                    log('üìπ Video call started successfully');

                } catch (mediaError) {
                    log(`‚ùå Media error: ${mediaError.message}`);
                }

            } catch (error) {
                log(`‚ùå Error joining video channel: ${error.message}`);
            }
        }

        async function handleUserPublished(user, mediaType) {
            log(`üìπ ${user.uid} started ${mediaType}`);
            
            try {
                await agoraClient.subscribe(user, mediaType);
                
                if (mediaType === 'video') {
                    const videoElement = document.getElementById(`video-${user.uid}`);
                    if (videoElement && user.videoTrack) {
                        user.videoTrack.play(videoElement);
                        const placeholder = videoElement.querySelector('.video-placeholder');
                        if (placeholder) placeholder.remove();
                    }
                }
                
                remoteUsers[user.uid] = user;
            } catch (error) {
                log(`‚ùå Error handling user published: ${error.message}`);
            }
        }

        function handleUserUnpublished(user, mediaType) {
            log(`üìπ ${user.uid} stopped ${mediaType}`);
            
            if (mediaType === 'video') {
                const videoElement = document.getElementById(`video-${user.uid}`);
                if (videoElement) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'video-placeholder';
                    placeholder.textContent = 'üìπ';
                    videoElement.innerHTML = '';
                    videoElement.appendChild(placeholder);
                }
            }
        }

        function handleUserLeft(user) {
            log(`üëã ${user.uid} left video call`);
            delete remoteUsers[user.uid];
            
            const videoElement = document.getElementById(`video-${user.uid}`);
            if (videoElement) {
                const placeholder = document.createElement('div');
                placeholder.className = 'video-placeholder';
                placeholder.textContent = 'üìπ';
                videoElement.innerHTML = '';
                videoElement.appendChild(placeholder);
            }
        }

        function initializeVideoForPlayer(playerId) {
            const remoteUser = remoteUsers[playerId];
            if (remoteUser && remoteUser.videoTrack) {
                const videoElement = document.getElementById(`video-${playerId}`);
                if (videoElement) {
                    remoteUser.videoTrack.play(videoElement);
                    const placeholder = videoElement.querySelector('.video-placeholder');
                    if (placeholder) placeholder.remove();
                }
            }
        }

        async function leaveVideoCall() {
            if (!isVideoJoined) return;

            try {
                log('üìπ Leaving video call...');
                
                if (localVideoTrack) {
                    localVideoTrack.stop();
                    localVideoTrack.close();
                }
                
                if (localAudioTrack) {
                    localAudioTrack.stop();
                    localAudioTrack.close();
                }
                
                if (agoraClient) {
                    await agoraClient.leave();
                }
                
                isVideoJoined = false;
                remoteUsers = {};
                log('üìπ Left video call');
                
            } catch (error) {
                log(`‚ùå Error leaving video call: ${error.message}`);
            }
        }

        // Initialize with clean state
        document.addEventListener('DOMContentLoaded', function() {
            log('üéÆ Game initialized with complete features!');
            
            initializeFocusState();
            
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendChatMessage();
                    }
                });
            }

            window.addEventListener('beforeunload', () => {
                completeCleanup();
            });
            
            window.addEventListener('beforeunload', () => {
                if (socket) {
                    socket.removeAllListeners();
                    socket.disconnect();
                }
                if (isVideoJoined) {
                    leaveVideoCall().catch(console.error);
                }
            });
        });

        // Memory cleanup
        setInterval(() => {
            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages && gameMessages.children.length > 100) {
                while (gameMessages.children.length > 50) {
                    gameMessages.removeChild(gameMessages.firstChild);
                }
            }
            
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages && chatMessages.children.length > 50) {
                while (chatMessages.children.length > 25) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
        }, 30000);
    </script>
</body>
</html>