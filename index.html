<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Screw Your Neighbor - Personal Table</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 10px 0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 15px;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        .game-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            opacity: 0.9;
            flex-wrap: wrap;
        }

        /* Personal Table Layout */
        .personal-table {
            margin-bottom: 15px;
        }

        .focus-grid {
            display: grid;
            grid-template-columns: 1fr 0.8fr 1fr;
            grid-template-rows: auto auto;
            gap: 8px;
            margin-bottom: 15px;
        }

        /* Top center - your own video (smaller) */
        .player-video-top {
            grid-column: 2;
            grid-row: 1;
            height: 80px;
        }

        /* Center - your card (main interaction zone) */
        .center-card-area {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 100, 0, 0.1);
            /* Subtle green felt hint */
            border-radius: 15px;
        }

        /* Left/Right trading partners (larger videos) */
        .left-trading-partner {
            grid-column: 1;
            grid-row: 2;
        }

        .right-trading-partner {
            grid-column: 3;
            grid-row: 2;
        }

        /* Bottom additional players */
        .bottom-players {
            grid-column: 1 / 4;
            grid-row: 3;
            display: flex;
            gap: 8px;
            justify-content: space-between;
        }


        .focus-slot {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px;
            min-height: 140px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .focus-slot.current-turn {
            border-color: #00FF00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            }

            50% {
                box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
            }
        }

        .focus-slot.custom {
            border-color: #FFD700;
            grid-row: 2;
        }

        .focus-slot.custom:first-of-type {
            grid-column: 1;
        }

        .focus-slot.custom:last-of-type {
            grid-column: 3;
        }

        .focus-slot.dealer {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }

        .focus-slot.empty {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
        }

        .focus-slot.empty .add-icon {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        /* Card + Video Side-by-Side Layout */
        .player-content {
            display: flex;
            gap: 8px;
            align-items: stretch;
            height: 100%;
        }

        .card-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .video-section {
            width: 80px;
            flex-shrink: 0;
        }

        .video-container {
            width: 100%;
            height: 60px;
            background: #333;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #222;
        }

        .video-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #555);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.7rem;
        }

        /* Enhanced Video Controls */
        .video-controls {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            gap: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .focus-slot:hover .video-controls {
            opacity: 1;
        }

        .video-control-btn {
            padding: 1px 2px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 2px;
            font-size: 0.5rem;
            cursor: pointer;
            transition: background 0.3s ease;
            flex: 1;
        }

        .video-control-btn:hover {
            background: rgba(0, 0, 0, 1);
        }

        .video-control-btn.active {
            background: #4caf50;
        }

        .video-control-btn.muted {
            background: #f44336;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.8rem;
        }

        .player-name {
            font-weight: bold;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-lives {
            background: rgba(255, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        /* Playing Card Design - Proper Card Proportions */
        .card-display {
            width: 80px;
            height: 110px;
            background: linear-gradient(145deg, #ffffff, #f8f8f8);
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            margin: 8px auto;
            transition: all 0.3s ease;
            font-family: 'Times New Roman', serif;
            font-size: 1rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }

        .card-display:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .card-display.face-down {
            background: linear-gradient(145deg, #1a237e, #303f9f);
            color: white;
            font-size: 1.5rem;
        }

        .card-display.face-down:hover {
            transform: scale(1.05);
        }

        .card-display.red {
            color: #d32f2f;
            background: linear-gradient(145deg, #ffffff, #fafafa);
        }

        .card-display.black {
            color: #212121;
            background: linear-gradient(145deg, #ffffff, #fafafa);
        }

        .card-display.revealed {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transform: scale(1.02);
        }

        /* Nudge Animations */
        .nudge-shake {
            animation: shake 0.5s ease-in-out infinite;
        }

        .nudge-pulse {
            animation: pulse-glow 1s ease-in-out;
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-3px) rotate(-1deg);
            }

            75% {
                transform: translateX(3px) rotate(1deg);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
                border-color: rgba(255, 215, 0, 0.6);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.9);
                border-color: rgba(255, 215, 0, 1);
            }
        }

        /* Gesture Feedback */
        .card-display.gesture-active {
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        }

        .card-display.king-auto {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
            animation: king-reveal 2s ease-out;
        }

        @keyframes king-reveal {
            0% {
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
            }

            50% {
                transform: scale(1.1) rotate(5deg);
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }

            100% {
                transform: scale(1.02) rotate(0deg);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            }
        }

        /* Card content styling */
        .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card-value {
            font-size: 1.1rem;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 2px;
        }

        .card-suit {
            font-size: 1.3rem;
            line-height: 1;
        }

        .action-button {
            width: 100%;
            padding: 6px 8px;
            background: #00a8ff;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 5px;
        }

        .action-button:hover {
            background: #0097e6;
            transform: translateY(-1px);
        }

        .action-button:disabled {
            background: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        .action-button.trade {
            background: #e74c3c;
        }

        .action-button.trade:hover {
            background: #c0392b;
        }

        .remove-button {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.8);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            display: none;
        }

        .focus-slot.custom .remove-button {
            display: block;
        }

        /* Available Players Bar */
        .available-players {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .available-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
            opacity: 0.8;
        }

        .players-scroll {
            display: flex;
            overflow-x: auto;
            gap: 8px;
            padding: 5px 0;
            scrollbar-width: thin;
        }

        .players-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .players-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .players-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .available-player {
            min-width: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            position: relative;
            flex-shrink: 0;
        }

        .available-player:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .available-player.focused {
            border-color: #00FF00;
            background: rgba(0, 255, 0, 0.1);
        }

        .available-player.current-turn {
            border-color: #00FF00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.4);
        }

        .available-player.dealer {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
        }

        .available-player.tradeable {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            animation: tradeGlow 2s infinite;
        }

        @keyframes tradeGlow {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(231, 76, 60, 0.3);
            }

            50% {
                box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
            }
        }

        .available-player .check-mark {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #00FF00;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .available-player .player-name {
            font-size: 0.7rem;
            margin-bottom: 3px;
            font-weight: bold;
        }

        /* Mini Cards - Proper Proportions */
        .available-player .mini-card {
            width: 30px;
            height: 42px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid #ddd;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 0.6rem;
            font-weight: bold;
            margin: 2px auto;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .available-player .mini-card.face-down {
            background: linear-gradient(145deg, #1a237e, #303f9f);
            color: white;
            font-size: 0.7rem;
        }

        .available-player .mini-card.red {
            color: #d32f2f;
        }

        .available-player .mini-card.black {
            color: #212121;
        }

        .available-player .mini-lives {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Game Controls */
        .game-controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .control-button {
            padding: 12px 8px;
            background: #27ae60;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }

        .control-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .control-button:disabled {
            background: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        .control-button.danger {
            background: #e74c3c;
        }

        .control-button.warning {
            background: #f39c12;
        }

        .control-button.primary {
            background: #3498db;
        }

        /* Chat and Game Log */
        .bottom-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .chat-section,
        .game-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            height: 150px;
            display: flex;
            flex-direction: column;
        }

        .section-title {
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-align: center;
            opacity: 0.8;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            font-size: 0.7rem;
            margin-bottom: 8px;
            scrollbar-width: thin;
        }

        .messages::-webkit-scrollbar {
            width: 4px;
        }

        .messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        .chat-input {
            display: flex;
            gap: 5px;
        }

        .chat-input input {
            flex: 1;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.8rem;
        }

        .chat-input input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .chat-input button {
            padding: 6px 12px;
            background: #3498db;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Menu Screens */
        .menu-screen {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            margin: 0 auto;
        }

        .menu-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #3498db;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .input-group {
            margin: 15px 0;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Loading and Status */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.1rem;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Responsive Design */
        @media (max-width: 480px) {
            .focus-grid {
                grid-template-columns: 1fr 0.7fr 1fr;
                gap: 6px;
            }

            .focus-slot {
                min-height: 120px;
                padding: 6px;
            }

            .video-container {
                height: 50px;
            }

            .video-section {
                width: 60px;
            }

            .game-controls {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }

            .control-button {
                padding: 8px 4px;
                font-size: 0.7rem;
            }

            .bottom-section {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .game-status {
                font-size: 0.8rem;
            }

            .card-display {
                width: 60px;
                height: 85px;
                font-size: 0.8rem;
            }

            .available-player .mini-card {
                width: 25px;
                height: 35px;
                font-size: 0.5rem;
            }
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success {
            border-left: 4px solid #27ae60;
        }

        .toast.error {
            border-left: 4px solid #e74c3c;
        }

        .toast.warning {
            border-left: 4px solid #f39c12;
        }

        /* Lives as Dots Display */
        .player-lives-dots {
            display: flex;
            gap: 2px;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 10px;
            flex-shrink: 0;
        }

        .life-dot {
            width: 8px;
            height: 8px;
            background: #e74c3c;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .life-dot.lost {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mini-lives-dots {
            display: flex;
            gap: 1px;
            justify-content: center;
            margin-top: 2px;
        }

        .mini-life-dot {
            width: 4px;
            height: 4px;
            background: #e74c3c;
            border-radius: 50%;
        }

        .mini-life-dot.lost {
            background: rgba(255, 255, 255, 0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Eliminated Player Styles */
        .focus-slot.eliminated {
            opacity: 0.5;
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .focus-slot.eliminated .card-display {
            opacity: 0.4;
            background: linear-gradient(145deg, #444, #666) !important;
            color: rgba(255, 255, 255, 0.6) !important;
            transform: scale(0.9);
        }

        .focus-slot.eliminated .player-name {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .eliminated-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
        }

        .available-player.eliminated {
            opacity: 0.4;
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .available-player.eliminated .player-name {
            text-decoration: line-through;
            opacity: 0.6;
        }

        /* Jack "Screw You!" animations */
        .jack-block-reveal {
            border: 4px solid #e74c3c !important;
            box-shadow: 0 0 30px rgba(231, 76, 60, 1) !important;
            animation: jackBlockPulse 2s ease-out;
            transform: scale(1.1) !important;
        }

        @keyframes jackRevealBurst {
            0% {
                opacity: 0;
                transform: scale(0.3);
                background: rgba(255, 0, 0, 0);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
                background: rgba(255, 0, 0, 0.9);
            }

            100% {
                opacity: 1;
                transform: scale(1);
                background: rgba(255, 0, 0, 0.8);
            }
        }

        @keyframes jackBounceIn {
            0% {
                transform: scale(0.3) rotate(-10deg);
                opacity: 0;
            }

            50% {
                transform: scale(1.1) rotate(5deg);
                opacity: 1;
            }

            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes jackBlockPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
                transform: scale(1.05);
            }

            25% {
                box-shadow: 0 0 40px rgba(231, 76, 60, 1);
                transform: scale(1.15) rotate(2deg);
            }

            50% {
                box-shadow: 0 0 50px rgba(231, 76, 60, 1);
                transform: scale(1.2) rotate(-2deg);
            }

            75% {
                box-shadow: 0 0 40px rgba(231, 76, 60, 1);
                transform: scale(1.15) rotate(1deg);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        @keyframes jackFlyOut {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }

            25% {
                transform: scale(1.5) rotate(360deg);
                opacity: 1;
                box-shadow: 0 0 30px rgba(231, 76, 60, 0.6);
            }

            50% {
                transform: scale(2) rotate(720deg);
                opacity: 1;
                box-shadow: 0 0 50px rgba(231, 76, 60, 0.8);
                left: 50%;
                top: 50%;
                margin-left: -40px;
                margin-top: -55px;
            }

            100% {
                transform: scale(3) rotate(1080deg);
                opacity: 1;
                box-shadow: 0 0 80px rgba(231, 76, 60, 1);
                left: 50%;
                top: 50%;
                margin-left: -40px;
                margin-top: -55px;
            }
        }

        @keyframes textBurstIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes jackShootOff {
            0% {
                transform: scale(2.5) rotate(1440deg) translateX(calc(50vw - 50%)) translateY(calc(50vh - 50%));
                opacity: 1;
            }

            100% {
                transform: scale(0.5) rotate(1800deg) translateX(150vw) translateY(-50vh);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <!-- Main Menu -->
    <div id="main-menu" class="menu-screen">
        <h1>üé¥ Screw Your Neighbor</h1>
        <p>Personal Table Experience</p>

        <button class="menu-button" onclick="showQuickMatch()">‚ö° Quick Match</button>
        <button class="menu-button" onclick="showCreateGame()">üéÆ Create Private Game</button>
        <button class="menu-button" onclick="showJoinGame()">üéØ Join Game</button>

        <div class="input-group">
            <label for="playerName">Your Name:</label>
            <input type="text" id="playerName" placeholder="Enter your name" value="Player">
        </div>
    </div>

    <!-- Quick Match Screen -->
    <div id="quick-match" class="menu-screen hidden">
        <h2>‚ö° Quick Match</h2>
        <p>Finding available games...</p>
        <div class="loading">
            <div class="spinner"></div>
            <span>Searching for players...</span>
        </div>
        <button class="menu-button" onclick="showMainMenu()">‚Üê Back</button>
    </div>

    <!-- Create Game Screen -->
    <div id="create-game" class="menu-screen hidden">
        <h2>üéÆ Create Private Game</h2>

        <div class="input-group">
            <label for="startingLives">Starting Lives:</label>
            <select id="startingLives">
                <option value="3">3 Lives</option>
                <option value="5">5 Lives</option>
                <option value="7">7 Lives</option>
            </select>
        </div>

        <div class="input-group">
            <label for="deckCount">Number of Decks:</label>
            <select id="deckCount">
                <option value="1">1 Deck</option>
                <option value="2">2 Decks</option>
            </select>
        </div>

        <button class="menu-button" onclick="createPrivateGame()">Create Game</button>
        <button class="menu-button" onclick="showMainMenu()">‚Üê Back</button>
    </div>

    <!-- Join Game Screen -->
    <div id="join-game" class="menu-screen hidden">
        <h2>üéØ Join Game</h2>

        <div class="input-group">
            <label for="gameCode">Game Code:</label>
            <input type="text" id="gameCode" placeholder="Enter game code" style="text-transform: uppercase;">
        </div>

        <button class="menu-button" onclick="joinGame()">Join Game</button>
        <button class="menu-button" onclick="showMainMenu()">‚Üê Back</button>
    </div>

    <!-- Game Content -->
    <div id="gameContent" class="container hidden">
        <!-- Header -->
        <div class="header">
            <h1>üé¥ Screw Your Neighbor</h1>
            <div class="game-status">
                <span id="gameCodeDisplay">Game: <strong>LOADING</strong></span>
                <span id="playerCount">Players: <strong>0/0</strong></span>
                <span id="connectionStatus">üî¥ Connecting...</span>
            </div>
        </div>

        <!-- Personal Table -->
        <div class="personal-table">
            <div class="focus-grid" id="focusGrid">
                <!-- Focus slots will be populated by JavaScript -->
            </div>
        </div>

        <!-- Available Players Bar -->
        <div class="available-players">
            <div class="available-title">Available Players - Tap to Focus</div>
            <div class="players-scroll" id="playersScroll">
                <!-- Available players will be populated by JavaScript -->
            </div>
        </div>

        <!-- Game Controls -->
        <div class="game-controls">
            <button class="control-button" id="flipCardBtn" onclick="handleFlipClick()" disabled>
                üé¥ Flip Card
            </button>
            <button class="control-button" id="keepCardBtn" onclick="handleKeepClick()" disabled>
                ‚úã Keep Card
            </button>
            <button class="control-button" id="tradeCardBtn" onclick="handleTradeClick()" disabled>
                üîÑ Trade Card
            </button>
            <button class="control-button warning" id="endRoundBtn" onclick="endRound()" disabled>
                ‚è∞ End Round
            </button>
            <button class="control-button danger" onclick="clearStuckCard()" style="background: purple;">
                üßπ Clear Card
            </button>
            <button class="control-button danger" onclick="leaveGame()">
                üö™ Leave
            </button>
        </div>

        <!-- Start Game Button (for host) -->
        <div id="hostControls" class="game-controls hidden">
            <button class="control-button primary" id="startGameBtn" onclick="startGame()">
                üöÄ Start Game
            </button>
        </div>

        <!-- Bottom Section -->
        <div class="bottom-section">
            <div class="chat-section">
                <div class="section-title">üí¨ Chat</div>
                <div class="messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
                    <button onclick="sendChatMessage()">Send</button>
                </div>
            </div>
            <div class="game-log">
                <div class="section-title">üìã Game Log</div>
                <div class="messages" id="gameMessages"></div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.19.1.js"></script>

    <script>
        // Global variables
        let socket = null;
        let currentGame = null;
        let playerId = null;
        let playerName = '';

        // Personal Table state
        let focusedPlayers = null;

        // Video state
        let isVideoJoined = false;
        let agoraClient = null;
        let localVideoTrack = null;
        let localAudioTrack = null;
        let remoteUsers = {};
        let videoStates = {};

        // Production optimizations
        let updateTimeout = null;
        let lastGameState = null;

        // Gesture and King Logic State
        let playerCardLooks = {}; // Track who has looked at their card
        let gestureState = {
            startX: 0,
            startY: 0,
            startTime: 0,
            isTracking: false,
            element: null,
            lastTap: 0
        };

        // Nudge system
        let nudgeTimeouts = {};
        let nudgeIntervals = {};

        // Auto-continue system
        let autoContinueTimer = null;
        let countdownSeconds = 15;
        let playersReadyForNext = new Set();

        // Utility functions
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = '[' + timestamp + '] ' + message;
            console.log(logMessage);
            addGameMessage(message);
        }

        function addGameMessage(message) {
            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages) {
                const messageDiv = document.createElement('div');
                messageDiv.textContent = message;
                gameMessages.appendChild(messageDiv);
                gameMessages.scrollTop = gameMessages.scrollHeight;

                while (gameMessages.children.length > 100) {
                    gameMessages.removeChild(gameMessages.firstChild);
                }
            }
        }

        function addChatMessage(playerName, message) {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = '<strong>' + playerName + ':</strong> ' + message;
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                while (chatMessages.children.length > 50) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 3000);
        }

        function createLivesDisplay(player, isMini = false) {
            const maxLives = currentGame?.settings?.startingLives || 3;
            const currentLives = player.lives || 0;

            if (isMini) {
                const miniLivesContainer = document.createElement('div');
                miniLivesContainer.className = 'mini-lives-dots';

                for (let i = 0; i < maxLives; i++) {
                    const dot = document.createElement('div');
                    dot.className = i < currentLives ? 'mini-life-dot' : 'mini-life-dot lost';
                    miniLivesContainer.appendChild(dot);
                }

                return miniLivesContainer;
            } else {
                const livesContainer = document.createElement('div');
                livesContainer.className = 'player-lives-dots';

                for (let i = 0; i < maxLives; i++) {
                    const dot = document.createElement('div');
                    dot.className = i < currentLives ? 'life-dot' : 'life-dot lost';
                    livesContainer.appendChild(dot);
                }

                return livesContainer;
            }
        }

        // Initialize clean focus state
        function initializeFocusState() {
            focusedPlayers = {
                leftNeighbor: null,
                currentTurn: null,
                rightNeighbor: null,
                custom1: null,
                custom2: null
            };
        }

        // Enhanced Gesture Detection System
        function initializeGestureHandlers(cardElement, targetPlayerId) {
            if (!cardElement) {
                log('‚ùå No card element to initialize gestures for player ' + targetPlayerId);
                return;
            }

            log('üéØ Initializing gesture handlers for player ' + targetPlayerId);

            // Touch events for mobile
            cardElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            cardElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            cardElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Mouse events for desktop
            cardElement.addEventListener('mousedown', handleMouseStart);
            cardElement.addEventListener('mousemove', handleMouseMove);
            cardElement.addEventListener('mouseup', handleMouseEnd);

            // Store player ID for gesture handling
            cardElement.dataset.playerId = targetPlayerId;

            log('‚úÖ Gesture handlers set for player ' + targetPlayerId);
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            startGesture(touch.clientX, touch.clientY, e.target);
            log('üì± Touch start: ' + touch.clientX + ', ' + touch.clientY);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!gestureState.isTracking) return;
            const touch = e.touches[0];
            updateGesture(touch.clientX, touch.clientY);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            log('üì± Touch end');
            endGesture();
        }

        function handleMouseStart(e) {
            startGesture(e.clientX, e.clientY, e.target);
            log('üñ±Ô∏è Mouse start: ' + e.clientX + ', ' + e.clientY);
        }

        function handleMouseMove(e) {
            if (!gestureState.isTracking) return;
            updateGesture(e.clientX, e.clientY);
        }

        function handleMouseEnd(e) {
            log('üñ±Ô∏è Mouse end');
            endGesture();
        }

        function startGesture(x, y, element) {
            gestureState.startX = x;
            gestureState.startY = y;
            gestureState.startTime = Date.now();
            gestureState.isTracking = true;
            gestureState.element = element;
            log('üéØ Gesture started at ' + x + ', ' + y);
        }

        function updateGesture(x, y) {
            if (!gestureState.isTracking) return;

            const deltaX = x - gestureState.startX;
            const deltaY = y - gestureState.startY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Visual feedback for swipe
            if (distance > 20) {
                const cardElement = gestureState.element.closest('.card-display');
                if (cardElement && deltaX > 50) {
                    cardElement.style.transform = 'translateX(' + Math.min(deltaX - 50, 30) + 'px) rotate(' + Math.min((deltaX - 50) / 5, 10) + 'deg)';
                    cardElement.style.opacity = '0.8';
                    log('üëâ Swipe feedback: deltaX=' + deltaX);
                }
            }
        }

        function endGesture() {
            if (!gestureState.isTracking) return;

            const duration = Date.now() - gestureState.startTime;
            const cardElement = gestureState.element.closest('.card-display');

            log('üéØ Gesture ended, duration: ' + duration + 'ms');

            if (cardElement) {
                // Check for swipe based on transform applied during updateGesture
                const transform = cardElement.style.transform || '';
                const wasSwipeRight = transform.includes('translateX') && !transform.includes('-');

                // Reset visual feedback
                cardElement.style.transform = '';
                cardElement.style.opacity = '';

                // Get the player ID from the card element's dataset
                const targetPlayerId = cardElement.dataset.playerId;
                log('üéØ Target player ID: ' + targetPlayerId);

                if (!targetPlayerId) {
                    log('‚ùå No target player ID found in card element');
                    gestureState.isTracking = false;
                    gestureState.element = null;
                    return;
                }

                if (wasSwipeRight) {
                    // Swipe right detected
                    log('üëâ Swipe right detected for player ' + targetPlayerId);
                    handleSwipeRight(targetPlayerId);
                } else if (duration < 300) {
                    // Quick tap
                    if (gestureState.lastTap && Date.now() - gestureState.lastTap < 500) {
                        // Double tap - Keep card
                        log('üëÜüëÜ Double tap detected for player ' + targetPlayerId);
                        handleDoubleTap(targetPlayerId);
                        gestureState.lastTap = 0;
                    } else {
                        // Single tap - Look at card
                        log('üëÜ Single tap detected for player ' + targetPlayerId);
                        gestureState.lastTap = Date.now();
                        handleSingleTap(targetPlayerId);
                    }
                }
            } else {
                log('‚ùå No card element found for gesture');
            }

            // Reset gesture state
            gestureState.isTracking = false;
            gestureState.element = null;
        }

        function handleSwipeRight(targetPlayerId) {
            log('üëâ Swipe feedback: Swipe right for player ' + targetPlayerId);
            if (targetPlayerId === playerId) {
                // Check if we can trade
                if (canPerformTrade()) {
                    const myPlayer = currentGame?.players?.find(p => p.id === playerId);
                    const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
                    const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

                    // FIXED: If dealer, always trade with deck on swipe
                    if (isDealerTurn) {
                        log('üé¥ Dealer swipe - trading with deck');
                        socket.emit('dealer-trade-deck', { gameId: currentGame.id });
                        showToast('Trading with deck...', 'info');
                        return;
                    }

                    // Normal player trading
                    const nextPlayer = getNextTradeablePlayer();
                    if (nextPlayer) {
                        log('üîÑ Trading with ' + nextPlayer.name);
                        requestTrade(nextPlayer.id);
                    } else {
                        log('‚ùå No valid trade target found');
                        showToast('No valid trade target!', 'warning');
                    }
                } else {
                    log('‚ùå Cannot trade right now');
                    showToast('Cannot trade right now!', 'warning');
                }
            }
        }

        function handleDoubleTap(targetPlayerId) {
            log('‚úÖ Double tap: Processing for player ' + targetPlayerId);
            if (targetPlayerId === playerId) {
                if (currentGame?.currentPlayerId === targetPlayerId) {
                    const myPlayer = currentGame?.players?.find(p => p.id === playerId);
                    const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
                    const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

                    if (isDealerTurn) {
                        log('‚úÖ Dealer double tap: Keeping card and ending round');
                        socket.emit('dealer-skip-trade', { gameId: currentGame.id });
                        showToast('Dealer kept card - Round ending!', 'success');
                    } else {
                        log('‚úÖ Double tap: It\'s my turn, keeping card');
                        socket.emit('skip-turn', { gameId: currentGame.id });
                    }
                } else {
                    log('‚ùå Double tap: Not my turn');
                    showToast('Not your turn!', 'warning');
                }
            }
        }

        function handleSingleTap(targetPlayerId) {
            log('üëÜ Single tap: Processing for player ' + targetPlayerId);
            if (targetPlayerId === playerId) {
                const myPlayer = currentGame?.players?.find(p => p.id === targetPlayerId);
                if (myPlayer && myPlayer.hasCard && !playerCardLooks[targetPlayerId]) {
                    log('üëÅÔ∏è Single tap: Flipping card for first look');
                    flipCard();
                    markPlayerAsLooked(targetPlayerId);

                    // ADDED: Check if we flipped a King and auto-advance
                    if (myPlayer.card && isKing(myPlayer.card)) {
                        log('üëë Flipped King - auto-advancing in 1.5 seconds');
                        setTimeout(() => {
                            if (currentGame?.currentPlayerId === targetPlayerId) {
                                log('üëë Auto-skipping turn for King holder');
                                socket.emit('skip-turn', { gameId: currentGame.id });
                                showToast('Your King auto-advances! üëë', 'success');
                            }
                        }, 1500); // Give time to see the King reveal animation
                    }
                } else {
                    log('üëÅÔ∏è Single tap: Player already looked or no card');
                }
            }
        }

        // King Logic Functions
        function isKing(card) {
            return card && (card.value === 'K' || card.value === 'King');
        }

        function isJack(card) {
            return card && (card.value === 'J' || card.value === 'Jack');
        }

        function shouldAutoRevealKing(player) {
            // For Kings, we want to auto-reveal even if already revealed locally
            return player && player.card && isKing(player.card);
        }

        function handleKingAutoReveal(player) {
            if (shouldAutoRevealKing(player)) {
                // Prevent multiple auto-reveals of the same King
                const autoRevealKey = player.id + '-king-revealed';
                if (window.autoRevealedKings && window.autoRevealedKings[autoRevealKey]) {
                    log('üëë King already auto-revealed for ' + player.name + ' - skipping');
                    return;
                }

                // Initialize tracking if needed
                if (!window.autoRevealedKings) {
                    window.autoRevealedKings = {};
                }
                window.autoRevealedKings[autoRevealKey] = true;

                log('üëë AUTO-REVEALING King for ' + player.name);

                // Mark as revealed for all players to see
                player.cardRevealed = true;

                if (player.id === playerId) {
                    // Auto-flip our own King and emit to server
                    socket?.emit('auto-reveal-king', {
                        gameId: currentGame.id,
                        playerId: player.id
                    });
                }

                markPlayerAsLooked(player.id);
                showToast(player.name + ' has a King! üëë', 'warning');

                // IMPROVED: Only auto-advance if it's actually their turn AND we're in trading phase
                setTimeout(() => {
                    if (currentGame?.currentPlayerId === player.id &&
                        (currentGame?.turnPhase === 'trading' || currentGame?.turnPhase === 'dealer-turn')) {
                        handleKingAutoAdvance(player.id);
                    } else {
                        log('üëë Not auto-advancing ' + player.name + ' - not their turn or wrong phase');
                    }
                }, 500);
            }
        }

        // Auto-advance when King is revealed
        function handleKingAutoAdvance(playerId) {
            const player = currentGame?.players?.find(p => p.id === playerId);
            if (!player || !player.card || !isKing(player.card)) return;

            log('üëë Auto-advancing ' + player.name + ' (has King)');

            // Check if it's actually this player's turn
            if (playerId !== currentGame?.currentPlayerId) {
                log('üëë Not ' + player.name + '\'s turn - skipping auto-advance');
                return;
            }

            // Check if we're in the right phase
            if (currentGame?.turnPhase !== 'trading' && currentGame?.turnPhase !== 'dealer-turn') {
                log('üëë Wrong phase (' + currentGame?.turnPhase + ') - skipping auto-advance');
                return;
            }

            log('üëë Auto-skipping ' + player.name + '\'s turn (has King)');

            // Add visual feedback
            showToast(player.name + '\'s King auto-advances! üëë', 'success');

            // Auto-emit skip turn after a brief delay for visual feedback
            setTimeout(() => {
                if (socket && currentGame && currentGame.currentPlayerId === playerId) {
                    log('üëë Emitting skip-turn for ' + player.name);
                    socket.emit('skip-turn', { gameId: currentGame.id });
                } else {
                    log('üëë Conditions changed - not emitting skip-turn');
                }
            }, 1500);
        }

        function canPerformTrade() {
            const isMyTurn = currentGame?.currentPlayerId === playerId;
            const gameStarted = currentGame?.state === 'playing';
            const tradingPhase = currentGame?.turnPhase === 'trading' || currentGame?.turnPhase === 'dealer-turn';
            const myPlayer = currentGame?.players?.find(p => p.id === playerId);

            log('üîç Trade check: myTurn=' + isMyTurn + ', gameStarted=' + gameStarted + ', tradingPhase=' + tradingPhase + ', phase=' + currentGame?.turnPhase);

            // Special case: Dealer can always trade with deck on their turn
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            if (isDealer && isMyTurn && gameStarted) {
                log('üëë Dealer can trade with deck');
                return true;
            }

            // Can't trade if I have a King (unless I'm dealer)
            if (myPlayer?.card && isKing(myPlayer.card) && !isDealer) {
                log('üëë Cannot trade: I have a King');
                showToast('Kings cannot be traded! üëë', 'warning');
                return false;
            }

            const canTrade = isMyTurn && gameStarted && tradingPhase;
            log('üîç Final trade result: ' + canTrade);
            return canTrade;
        }

        function getNextTradeablePlayer() {
            if (!currentGame?.players) return null;

            const myIndex = currentGame.players.findIndex(p => p.id === playerId);
            if (myIndex === -1) return null;

            const playerCount = currentGame.players.length;
            let nextIndex = (myIndex + 1) % playerCount;
            let searchCount = 0;

            // Find next player who doesn't have a revealed King
            while (searchCount < playerCount) {
                const nextPlayer = currentGame.players[nextIndex];

                // Check if player has revealed King
                if (nextPlayer.card && isKing(nextPlayer.card) && nextPlayer.cardRevealed) {
                    // Special case: If DEALER has King, trade with deck
                    if (nextPlayer.id === currentGame.dealerId) {
                        log('üëë DEALER ' + nextPlayer.name + ' has King - trade with deck!');
                        return { id: 'TRADE_WITH_DECK', name: 'Deck', isDealer: true };
                    }
                    // Normal case: Bypass non-dealer King holders
                    else {
                        log('üëë Bypassing ' + nextPlayer.name + ' (has King)');
                        nextIndex = (nextIndex + 1) % playerCount;
                        searchCount++;
                        continue;
                    }
                }

                // Valid trade target (no King or not revealed)
                if (nextPlayer.lives > 0 && nextPlayer.id !== playerId) {
                    return nextPlayer;
                }

                nextIndex = (nextIndex + 1) % playerCount;
                searchCount++;
            }

            return null;
        }

        // Card visibility function - show own cards, revealing phase cards, and auto-revealed Kings
        function shouldPlayerCardBeVisible(player) {
            // Always show your own card
            if (player.id === playerId) {
                return true;
            }

            // Show other players' cards during the revealing phase at the end of the round
            if (currentGame.turnPhase === 'revealing') {
                return true;
            }

            // üéØ NEW: Show auto-revealed Kings during normal gameplay
            if (player.card && isKing(player.card) && player.cardRevealed) {
                return true;
            }

            // Don't show other players' cards during normal gameplay otherwise
            return false;
        }

        function canTradeWith(player) {
            if (!currentGame) return false;

            const isMyTurn = currentGame.currentPlayerId === playerId;
            const gameStarted = currentGame.state === 'playing';
            const tradingPhase = currentGame.turnPhase === 'trading';

            if (!isMyTurn || !gameStarted || !tradingPhase || player.lives <= 0) {
                return false;
            }

            const myPlayer = currentGame.players.find(p => p.id === playerId);
            if (myPlayer?.card && isKing(myPlayer.card)) {
                return false;
            }

            const nextTradeablePlayer = getNextTradeablePlayer();
            const canTrade = nextTradeablePlayer && player.id === nextTradeablePlayer.id;

            if (canTrade) {
                log('üîÑ ' + player.name + ' is valid trade target');
            }

            return canTrade;
        }

        // Card Look Tracking
        function markPlayerAsLooked(playerId) {
            playerCardLooks[playerId] = true;
            log('üëÅÔ∏è Player ' + playerId + ' has looked at their card');
            clearNudge(playerId);

            // FIXED: Check if it's any player (removed the wrong condition)
            if (currentGame?.players) {
                const player = currentGame.players.find(p => p.id === playerId);
                if (player) {
                    player.hasLookedAtCard = true;
                    log('üëÅÔ∏è Marked ' + playerId + ' as looked in game state');
                }
            }
        }

        function hasPlayerLooked(playerId) {
            // Check local tracking first
            if (playerCardLooks[playerId]) {
                return true;
            }

            // ADDED: Fallback to game state
            const player = currentGame?.players?.find(p => p.id === playerId);
            if (player && player.hasLookedAtCard) {
                // Sync local tracking
                playerCardLooks[playerId] = true;
                return true;
            }

            return false;
        }

        function resetCardLooks() {
            playerCardLooks = {};
            window.autoRevealedKings = {}; // Add this line
            log('üîÑ Reset all card look tracking and King reveals'); // Updated log message
        }

        // Nudge System
        function startNudge(playerId, reason = 'Look at your card') {
            clearNudge(playerId); // Clear any existing nudge

            const playerElement = document.querySelector('[data-player-id="' + playerId + '"]')?.closest('.focus-slot');
            if (!playerElement) return;

            const cardElement = playerElement.querySelector('.card-display');
            if (!cardElement) return;

            log('üîî Starting nudge for player ' + playerId + ': ' + reason);

            // Visual nudge - shake animation
            cardElement.classList.add('nudge-shake');

            // Audio nudge (optional)
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmoeAzeI1PKscBkFl3bvuKJcHA==');
                audio.volume = 0.3;
                audio.play().catch(() => { }); // Ignore audio errors
            } catch (error) {
                // Ignore audio errors
            }

            // Pulse effect
            nudgeIntervals[playerId] = setInterval(() => {
                if (cardElement.classList.contains('nudge-pulse')) {
                    cardElement.classList.remove('nudge-pulse');
                } else {
                    cardElement.classList.add('nudge-pulse');
                }
            }, 1000);

            // Auto-clear after 10 seconds
            nudgeTimeouts[playerId] = setTimeout(() => {
                clearNudge(playerId);
            }, 10000);

            // Show toast
            showToast(reason + ' üëÜ', 'warning');
        }

        function clearNudge(playerId) {
            const playerElement = document.querySelector('[data-player-id="' + playerId + '"]')?.closest('.focus-slot');
            if (playerElement) {
                const cardElement = playerElement.querySelector('.card-display');
                if (cardElement) {
                    cardElement.classList.remove('nudge-shake', 'nudge-pulse');
                }
            }

            if (nudgeTimeouts[playerId]) {
                clearTimeout(nudgeTimeouts[playerId]);
                delete nudgeTimeouts[playerId];
            }

            if (nudgeIntervals[playerId]) {
                clearInterval(nudgeIntervals[playerId]);
                delete nudgeIntervals[playerId];
            }
        }

        function clearAllNudges() {
            Object.keys(nudgeTimeouts).forEach(playerId => clearNudge(playerId));
        }

        // Username validation functions
        function validatePlayerName(name) {
            if (!name || name.trim().length === 0) {
                showToast('Please enter a valid name', 'error');
                return false;
            }

            if (name.trim().length > 20) {
                showToast('Name must be 20 characters or less', 'error');
                return false;
            }

            // Check for inappropriate characters
            const validName = /^[a-zA-Z0-9\s_-]+$/.test(name.trim());
            if (!validName) {
                showToast('Name can only contain letters, numbers, spaces, underscore, and dash', 'error');
                return false;
            }

            return true;
        }

        function checkForDuplicateUsername(name) {
            if (currentGame && currentGame.players) {
                const duplicate = currentGame.players.find(p =>
                    p.name.toLowerCase().trim() === name.toLowerCase().trim() && p.id !== playerId
                );
                if (duplicate) {
                    showToast('Name "' + name + '" is already taken in this game', 'error');
                    return true;
                }
            }
            return false;
        }

        // Enhanced game state cleanup
        function cleanupGameState() {
            if (!currentGame || !currentGame.players) return;

            const originalCount = currentGame.players.length;

            // Remove duplicate players by ID
            const uniquePlayers = [];
            const seenIds = new Set();

            currentGame.players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                } else {
                    log('üóëÔ∏è Removing duplicate player: ' + player.name + ' (' + player.id + ')');
                }
            });

            if (originalCount !== uniquePlayers.length) {
                log('üîß Game cleanup: ' + originalCount + ' -> ' + uniquePlayers.length + ' players');
                currentGame.players = uniquePlayers;

                // Update display after cleanup
                updateGameDisplay();
                updatePersonalTable();

                showToast('Cleaned up ' + (originalCount - uniquePlayers.length) + ' duplicate players', 'success');
            }
        }

        // Available Players Management
        function renderAvailablePlayers() {
            const playersScroll = document.getElementById('playersScroll');
            if (!playersScroll) return;

            playersScroll.innerHTML = '';

            if (!currentGame || !currentGame.players) return;

            // Deduplicate players before rendering
            const uniquePlayers = [];
            const seenIds = new Set();

            currentGame.players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                }
            });

            const playerCount = uniquePlayers.length;
            if (playerCount <= 5) {
                return;
            }

            const addedPlayerIds = new Set();
            const playersNotInFocus = uniquePlayers.filter(player => {
                return !isPlayerInFocus(player.id);
            });

            playersNotInFocus.forEach(player => {
                if (addedPlayerIds.has(player.id)) {
                    return;
                }
                addedPlayerIds.add(player.id);

                const playerDiv = document.createElement('div');
                let playerClasses = 'available-player';

                if (player.id === currentGame.currentPlayerId) {
                    playerClasses += ' current-turn';
                }

                if (player.id === currentGame.dealerId) {
                    playerClasses += ' dealer';
                }

                if (canTradeWith(player)) {
                    playerClasses += ' tradeable';
                }

                // Check if player is eliminated
                if (player.lives <= 0) {
                    playerClasses += ' eliminated';
                }

                playerDiv.className = playerClasses;

                const playerNameDiv = document.createElement('div');
                playerNameDiv.className = 'player-name';
                playerNameDiv.textContent = player.name;
                playerDiv.appendChild(playerNameDiv);

                const miniCard = document.createElement('div');
                miniCard.className = 'mini-card';

                // Use the same card visibility logic
                const shouldShowCard = shouldPlayerCardBeVisible(player);

                if (player.card && shouldShowCard) {
                    const isRed = player.card.suit === '‚ô•' || player.card.suit === '‚ô¶';
                    miniCard.className += isRed ? ' red' : ' black';
                    miniCard.textContent = player.card.value + player.card.suit;
                } else if (player.hasCard || player.card) {
                    miniCard.className += ' face-down';
                    miniCard.textContent = 'üÇ†';
                } else {
                    miniCard.textContent = '‚Äî';
                }
                playerDiv.appendChild(miniCard);

                const miniLivesDisplay = createLivesDisplay(player, true);
                playerDiv.appendChild(miniLivesDisplay);

                playerDiv.onclick = () => addToFocus(player);
                playersScroll.appendChild(playerDiv);
            });

            log('‚úÖ Rendered ' + addedPlayerIds.size + ' available players (deduplicated)');
        }

        function addToFocus(player) {
            if (!focusedPlayers) initializeFocusState();

            const playerCount = currentGame.players.length;

            if (playerCount <= 5) {
                log('Auto-fill mode active - cannot manually add players');
                return;
            }

            if (isPlayerInFocus(player.id)) {
                log('Player ' + player.name + ' already in focus');
                return;
            }

            if (!focusedPlayers.custom1) {
                focusedPlayers.custom1 = player;
                log('Added ' + player.name + ' to custom1');
            } else if (!focusedPlayers.custom2) {
                focusedPlayers.custom2 = player;
                log('Added ' + player.name + ' to custom2');
            } else {
                focusedPlayers.custom1 = player;
                log('Replaced custom1 with ' + player.name);
            }

            renderPersonalTable();
            renderAvailablePlayers();

            setTimeout(() => {
                initializeVideoForPlayer(player.id);
            }, 100);
        }

        function removeFromFocus(playerId) {
            if (!focusedPlayers) return;

            const playerCount = currentGame.players.length;

            if (playerCount <= 5) {
                log('Auto-fill mode active - cannot manually remove players');
                return;
            }

            if (focusedPlayers.custom1 && focusedPlayers.custom1.id === playerId) {
                focusedPlayers.custom1 = null;
                log('Removed player from custom1');
            } else if (focusedPlayers.custom2 && focusedPlayers.custom2.id === playerId) {
                focusedPlayers.custom2 = null;
                log('Removed player from custom2');
            }

            renderPersonalTable();
            renderAvailablePlayers();
        }

        function isPlayerInFocus(playerId) {
            if (!focusedPlayers) return false;
            return Object.values(focusedPlayers).some(player => player && player.id === playerId);
        }

        // Personal Table management
        function updatePersonalTable() {
            if (!currentGame || !currentGame.players || !Array.isArray(currentGame.players)) return;
            if (!focusedPlayers) initializeFocusState();

            cleanupGameState();

            const myPlayerIndex = currentGame.players.findIndex(p => p.id === playerId);
            if (myPlayerIndex === -1) {
                log('‚ùå Cannot find myself (' + playerId + ') in players list');
                return;
            }

            const playerCount = currentGame.players.length;
            if (playerCount < 2) return;

            log('üîÑ Updating personal table: ' + playerCount + ' players, I am ' + currentGame.players[myPlayerIndex].name + ' at index ' + myPlayerIndex);

            // üéØ NEW: Check if player layout actually changed
            const currentLayout = getCurrentLayoutSnapshot();

            if (playerCount <= 5) {
                autoFillAllPlayers(myPlayerIndex, playerCount);
                hideAvailablePlayersSection();
            } else {
                setupCustomFocusMode(myPlayerIndex, playerCount);
                showAvailablePlayersSection();
            }

            const newLayout = getCurrentLayoutSnapshot();

            // Only rebuild DOM if layout actually changed
            if (layoutChanged(currentLayout, newLayout)) {
                log('üîÑ Layout changed - rebuilding with video preservation...');
                renderPersonalTable();
            } else {
                log('üì± Layout unchanged - updating states only...');
                updateExistingPlayerStates();
            }

            renderAvailablePlayers();
        }

        function autoFillAllPlayers(myPlayerIndex, playerCount) {
            const players = currentGame.players;

            // Deduplicate players by ID to prevent duplicate issues
            const uniquePlayers = [];
            const seenIds = new Set();

            players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                }
            });

            log('üîß Deduplication: ' + players.length + ' players -> ' + uniquePlayers.length + ' unique players');

            // Update currentGame with deduplicated players
            currentGame.players = uniquePlayers;

            // Recalculate indices with clean player list
            const cleanMyPlayerIndex = uniquePlayers.findIndex(p => p.id === playerId);
            const cleanPlayerCount = uniquePlayers.length;

            if (cleanMyPlayerIndex === -1) {
                log('‚ùå Cannot find myself in clean players list');
                return;
            }

            focusedPlayers.currentTurn = uniquePlayers[cleanMyPlayerIndex];

            const leftNeighborIndex = (cleanMyPlayerIndex - 1 + cleanPlayerCount) % cleanPlayerCount;
            const rightNeighborIndex = (cleanMyPlayerIndex + 1) % cleanPlayerCount;

            // Smart arrangement: prioritize living players for neighbors
            const alivePlayers = uniquePlayers.filter(p => p.lives > 0);
            const deadPlayers = uniquePlayers.filter(p => p.lives <= 0);

            if (alivePlayers.length > 1) {
                // Find my position among alive players
                const myAliveIndex = alivePlayers.findIndex(p => p.id === playerId);
                const aliveCount = alivePlayers.length;

                if (myAliveIndex !== -1) {
                    if (aliveCount === 2) {
                        // üéØ FIXED: Special 2-player layout - no duplicates!
                        const otherPlayer = alivePlayers.find(p => p.id !== playerId);
                        focusedPlayers.leftNeighbor = null;
                        focusedPlayers.rightNeighbor = otherPlayer;
                        focusedPlayers.custom1 = null;
                        focusedPlayers.custom2 = null;

                        log('üéØ 2-player layout: Center=' + uniquePlayers[cleanMyPlayerIndex]?.name + ', Right=' + otherPlayer?.name);
                    } else {
                        // Normal logic for 3+ players
                        const leftAliveIndex = (myAliveIndex - 1 + aliveCount) % aliveCount;
                        const rightAliveIndex = (myAliveIndex + 1) % aliveCount;

                        focusedPlayers.leftNeighbor = alivePlayers[leftAliveIndex];
                        focusedPlayers.rightNeighbor = alivePlayers[rightAliveIndex];

                        // Fill custom slots with remaining alive players, then dead players
                        const otherAlivePlayers = alivePlayers.filter((p, index) =>
                            index !== myAliveIndex &&
                            index !== leftAliveIndex &&
                            index !== rightAliveIndex
                        );

                        const customPlayers = [...otherAlivePlayers, ...deadPlayers];
                        focusedPlayers.custom1 = customPlayers[0] || null;
                        focusedPlayers.custom2 = customPlayers[1] || null;

                        log('üéØ Multi-player layout: Left=' + alivePlayers[leftAliveIndex]?.name + ', Center=' + uniquePlayers[cleanMyPlayerIndex]?.name + ', Right=' + alivePlayers[rightAliveIndex]?.name);
                    }
                }
            } else {
                // Fallback to original logic if somehow we have no alive players
                focusedPlayers.leftNeighbor = uniquePlayers[leftNeighborIndex];
                focusedPlayers.rightNeighbor = uniquePlayers[rightNeighborIndex];

                const remainingPlayers = uniquePlayers.filter((p, index) =>
                    index !== cleanMyPlayerIndex &&
                    index !== leftNeighborIndex &&
                    index !== rightNeighborIndex
                );

                focusedPlayers.custom1 = remainingPlayers[0] || null;
                focusedPlayers.custom2 = remainingPlayers[1] || null;
            }

            log('üéØ Clean personal view: Left=' + uniquePlayers[leftNeighborIndex]?.name + ', Center=' + uniquePlayers[cleanMyPlayerIndex]?.name + ', Right=' + uniquePlayers[rightNeighborIndex]?.name);
        }

        function setupCustomFocusMode(myPlayerIndex, playerCount) {
            const players = currentGame.players;

            // Deduplicate players by ID
            const uniquePlayers = [];
            const seenIds = new Set();

            players.forEach(player => {
                if (!seenIds.has(player.id)) {
                    uniquePlayers.push(player);
                    seenIds.add(player.id);
                }
            });

            log('üîß Custom mode deduplication: ' + players.length + ' -> ' + uniquePlayers.length + ' unique');

            // Update currentGame with deduplicated players
            currentGame.players = uniquePlayers;

            // Recalculate with clean data
            const cleanMyPlayerIndex = uniquePlayers.findIndex(p => p.id === playerId);
            const cleanPlayerCount = uniquePlayers.length;

            if (cleanMyPlayerIndex === -1) return;

            focusedPlayers.currentTurn = uniquePlayers[cleanMyPlayerIndex];

            const leftNeighborIndex = (cleanMyPlayerIndex - 1 + cleanPlayerCount) % cleanPlayerCount;
            const rightNeighborIndex = (cleanMyPlayerIndex + 1) % cleanPlayerCount;

            focusedPlayers.leftNeighbor = uniquePlayers[leftNeighborIndex];
            focusedPlayers.rightNeighbor = uniquePlayers[rightNeighborIndex];

            if (focusedPlayers.custom1 && !uniquePlayers.find(p => p.id === focusedPlayers.custom1.id)) {
                focusedPlayers.custom1 = null;
            }
            if (focusedPlayers.custom2 && !uniquePlayers.find(p => p.id === focusedPlayers.custom2.id)) {
                focusedPlayers.custom2 = null;
            }

            const dealer = uniquePlayers.find(p => p.id === currentGame.dealerId);
            if (dealer && !isPlayerInFocus(dealer.id)) {
                if (!focusedPlayers.custom1) {
                    focusedPlayers.custom1 = dealer;
                } else if (!focusedPlayers.custom2) {
                    focusedPlayers.custom2 = dealer;
                }
            }

            log('üéØ Clean custom view: Left=' + uniquePlayers[leftNeighborIndex]?.name + ', Center=' + uniquePlayers[cleanMyPlayerIndex]?.name + ', Right=' + uniquePlayers[rightNeighborIndex]?.name);
        }

        function hideAvailablePlayersSection() {
            const availableSection = document.querySelector('.available-players');
            if (availableSection) {
                availableSection.style.display = 'none';
            }
        }

        function showAvailablePlayersSection() {
            const availableSection = document.querySelector('.available-players');
            if (availableSection) {
                availableSection.style.display = 'block';
            }
        }

        function renderPersonalTable() {
            const focusGrid = document.getElementById('focusGrid');
            if (!focusGrid || !focusedPlayers) return;

            // üéØ CRITICAL: Store existing video streams BEFORE clearing DOM
            const videoStreams = new Map();
            focusGrid.querySelectorAll('.video-element').forEach(video => {
                if (video.id) {
                    // Check if this video has active content (not just placeholder)
                    const hasActiveVideo = !video.querySelector('.video-placeholder') && video.children.length > 0;
                    if (hasActiveVideo) {
                        videoStreams.set(video.id, {
                            element: video.cloneNode(true),
                            hasContent: true
                        });
                        log('üíæ Stored video stream: ' + video.id);
                    }
                }
            });

            focusGrid.innerHTML = '';

            const leftSlot = createFocusSlot('slot', focusedPlayers.leftNeighbor, false);
            leftSlot.style.gridColumn = '1';
            leftSlot.style.gridRow = '1';
            focusGrid.appendChild(leftSlot);

            const centerSlot = createFocusSlot('slot', focusedPlayers.currentTurn, false);
            centerSlot.style.gridColumn = '2';
            centerSlot.style.gridRow = '1';
            focusGrid.appendChild(centerSlot);

            const rightSlot = createFocusSlot('slot', focusedPlayers.rightNeighbor, false);
            rightSlot.style.gridColumn = '3';
            rightSlot.style.gridRow = '1';
            focusGrid.appendChild(rightSlot);

            const custom1Slot = createFocusSlot('custom', focusedPlayers.custom1, true);
            custom1Slot.style.gridColumn = '1';
            custom1Slot.style.gridRow = '2';
            focusGrid.appendChild(custom1Slot);

            const custom2Slot = createFocusSlot('custom', focusedPlayers.custom2, true);
            custom2Slot.style.gridColumn = '3';
            custom2Slot.style.gridRow = '2';
            focusGrid.appendChild(custom2Slot);

            // üéØ CRITICAL: Restore video streams after DOM rebuild
            setTimeout(() => {
                restoreVideoStreams(videoStreams);
            }, 50);

            // Dealer badge logic
            const existingNotification = document.querySelector('.dealer-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId && currentGame?.state === 'playing';

            if (isDealerTurn) {
                const dealerBadge = document.createElement('div');
                dealerBadge.className = 'dealer-badge';
                dealerBadge.style.cssText = 'position: absolute; top: 8px; right: 8px; background: linear-gradient(45deg, #f39c12, #e67e22); color: white; padding: 4px 8px; border-radius: 8px; font-weight: bold; font-size: 0.6rem; box-shadow: 0 2px 6px rgba(243, 156, 18, 0.4); z-index: 10; animation: pulse 2s infinite; border: 1px solid rgba(255,255,255,0.3);';
                dealerBadge.textContent = 'üèÅ FINAL';

                const centerSlot = document.querySelector('[data-player-id="' + playerId + '"]')?.closest('.focus-slot');
                if (centerSlot) {
                    centerSlot.style.position = 'relative';
                    centerSlot.appendChild(dealerBadge);
                }
            }
        }

        function createFocusSlot(type, player, removable) {
            const slot = document.createElement('div');
            let slotClasses = 'focus-slot ' + type;

            if (!player) {
                slot.classList.add('empty');
                slot.innerHTML = '<div class="add-icon">+</div><div>Tap player below</div>';
                return slot;
            }

            if (player.id === currentGame?.currentPlayerId) {
                slotClasses += ' current-turn';
            }

            if (player.id === currentGame?.dealerId) {
                slotClasses += ' dealer';
            }

            if (player.lives <= 0) {
                slotClasses += ' eliminated';
            }

            slot.className = slotClasses;

            if (player && player.lives <= 0) {
                const eliminatedIndicator = document.createElement('div');
                eliminatedIndicator.className = 'eliminated-indicator';
                eliminatedIndicator.textContent = 'ELIMINATED';
                slot.appendChild(eliminatedIndicator);
            }

            const playerContent = document.createElement('div');
            playerContent.className = 'player-content';

            const cardSection = document.createElement('div');
            cardSection.className = 'card-section';

            const playerInfo = document.createElement('div');
            playerInfo.className = 'player-info';
            const dealerText = (player.id === currentGame?.dealerId) ? ' (Dealer)' : '';
            playerInfo.innerHTML = '<span class="player-name">' + player.name + dealerText + '</span>';

            const livesDisplay = createLivesDisplay(player, false);
            playerInfo.appendChild(livesDisplay);

            const cardDisplay = document.createElement('div');
            cardDisplay.className = 'card-display';

            const shouldShowCard = shouldPlayerCardBeVisible(player);

            if (player.card && shouldShowCard && player.lives > 0) {
                const card = player.card;
                const isRed = card.suit === '‚ô•' || card.suit === '‚ô¶';
                let cardClasses = isRed ? ' red revealed' : ' black revealed';

                if (isKing(card)) {
                    cardClasses += ' king-auto';
                }

                cardDisplay.className += cardClasses;

                const cardContent = document.createElement('div');
                cardContent.className = 'card-content';
                cardContent.innerHTML = '<div class="card-value">' + card.value + '</div><div class="card-suit">' + card.suit + '</div>';
                cardDisplay.appendChild(cardContent);
            } else if ((player.hasCard || player.card) && player.lives > 0) {
                cardDisplay.className += ' face-down';
                cardDisplay.textContent = 'üÇ†';
            } else {
                cardDisplay.textContent = 'No Card';
            }

            // SET THE PLAYER ID ON THE CARD ELEMENT
            cardDisplay.dataset.playerId = player.id;

            cardSection.appendChild(playerInfo);
            cardSection.appendChild(cardDisplay);
            cardSection.setAttribute('data-player-id', player.id);

            // INITIALIZE GESTURE HANDLERS FOR MY CARD
            if (player.id === playerId && cardDisplay) {
                initializeGestureHandlers(cardDisplay, player.id);
            }

            // Action buttons and video section code continues...
            const videoSection = document.createElement('div');
            videoSection.className = 'video-section';

            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';

            const videoElement = document.createElement('div');
            videoElement.className = 'video-element';
            videoElement.id = 'video-' + player.id;

            const placeholder = document.createElement('div');
            placeholder.className = 'video-placeholder';
            placeholder.textContent = 'üìπ';
            videoElement.appendChild(placeholder);

            const videoControls = document.createElement('div');
            videoControls.className = 'video-controls';
            videoControls.innerHTML = '<button class="video-control-btn" onclick="startVideoForPlayer(\'' + player.id + '\')" title="Start Video">üì∑</button><button class="video-control-btn" onclick="toggleMuteForPlayer(\'' + player.id + '\')" title="Mute">üé§</button><button class="video-control-btn" onclick="endVideoForPlayer(\'' + player.id + '\')" title="End">‚ùå</button>';

            videoContainer.appendChild(videoElement);
            videoContainer.appendChild(videoControls);
            videoSection.appendChild(videoContainer);

            playerContent.appendChild(cardSection);
            playerContent.appendChild(videoSection);
            slot.appendChild(playerContent);

            if (removable) {
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-button';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeFromFocus(player.id);
                };
                slot.appendChild(removeBtn);
            }

            return slot;
        }

        // Video Controls
        function startVideoForPlayer(playerId) {
            if (playerId === playerId) {
                initializeVideoCall();
            }
            showToast('üìπ Video starting for player', 'info');
        }

        function toggleMuteForPlayer(playerId) {
            if (playerId === playerId && localAudioTrack) {
                const enabled = localAudioTrack.enabled;
                localAudioTrack.setEnabled(!enabled);
                showToast('üé§ ' + (enabled ? 'Muted' : 'Unmuted'), 'info');

                const btn = document.querySelector('[onclick="toggleMuteForPlayer(\'' + playerId + '\')"]');
                if (btn) {
                    btn.className = enabled ? 'video-control-btn muted' : 'video-control-btn';
                    btn.textContent = enabled ? 'üîá' : 'üé§';
                }
            }
        }

        function endVideoForPlayer(playerId) {
            if (playerId === playerId) {
                leaveVideoCall();
            }
            showToast('üìπ Video ended for player', 'info');
        }

        // Enhanced Game action handlers
        function handleFlipClick() {
            log('üé¥ Flip Card button clicked');
            flipCard();
        }

        function handleKeepClick() {
            log('‚úã Keep Card button clicked');
            if (currentGame?.currentPlayerId !== playerId) {
                log('‚ùå Not my turn! Current turn: ' + currentGame?.currentPlayerId + ', Me: ' + playerId);
                showToast('Not your turn!', 'warning');
                return;
            }

            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

            // Handle dealer keep (should end round)
            if (isDealerTurn) {
                log('‚úã Dealer keeping card - this should END the round');
                if (!socket || !currentGame) {
                    log('‚ùå Dealer keep failed: no socket or game');
                    return;
                }

                // Emit dealer skip trade (keep card)
                socket.emit('dealer-skip-trade', { gameId: currentGame.id });
                showToast('Dealer kept card - Round ending!', 'success');
                return;
            }

            // Normal keep card logic
            keepCard();
        }

        function handleTradeClick() {
            log('üîÑ Trade Card button clicked');

            const myPlayer = currentGame?.players?.find(p => p.id === playerId);
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && currentGame?.currentPlayerId === playerId;

            // Handle dealer deck trading
            if (isDealerTurn) {
                log('üé¥ Dealer trading with deck');
                if (!socket || !currentGame) {
                    log('‚ùå Dealer deck trade failed: no socket or game');
                    return;
                }

                // Emit dealer deck trade
                socket.emit('dealer-trade-deck', { gameId: currentGame.id });
                showToast('Trading with deck...', 'info');
                return;
            }

            // Normal player trading logic
            if (!canPerformTrade()) {
                log('‚ùå Cannot trade right now');
                showToast('Cannot trade right now!', 'warning');
                return;
            }

            const nextPlayer = getNextTradeablePlayer();
            if (nextPlayer) {
                log('üîÑ Trading with ' + nextPlayer.name);
                requestTrade(nextPlayer.id);
            } else {
                log('‚ùå No valid trade target');
                showToast('No valid trade target!', 'warning');
            }
        }

        // Game actions
        function startGame() {
            if (!socket || !currentGame) {
                showToast('Game not ready', 'error');
                return;
            }

            if (currentGame.hostId !== playerId) {
                showToast('Only the host can start the game', 'error');
                return;
            }

            const settings = { startingLives: 3, deckCount: 1 };

            socket.emit('start-game', {
                gameId: currentGame.id,
                settings
            });
            log('üöÄ Starting game...');
        }

        function flipCard() {
            if (!socket || !currentGame) {
                log('‚ùå Flip card failed: no socket or game');
                return;
            }

            log('üé¥ Flipping card for player ' + playerId);
            socket.emit('flip-card', { gameId: currentGame.id });

            // FIXED: Mark as looked immediately when flipping
            markPlayerAsLooked(playerId);
        }

        function keepCard() {
            if (!socket || !currentGame) {
                log('‚ùå Keep card failed: no socket or game');
                return;
            }

            // Check if it's actually my turn
            if (currentGame.currentPlayerId !== playerId) {
                log('‚ùå Keep card failed: not my turn (current: ' + currentGame.currentPlayerId + ', me: ' + playerId + ')');
                showToast('Not your turn!', 'warning');
                return;
            }

            const myPlayer = currentGame.players?.find(p => p.id === playerId);
            if (myPlayer?.card && isKing(myPlayer.card)) {
                log('üëë Keeping King (automatic)');
                showToast('Keeping your King! üëë', 'success');
            } else {
                log('‚úã Keeping your card...');
            }

            socket.emit('skip-turn', { gameId: currentGame.id });
        }

        function requestTrade(targetPlayerId) {
            if (!socket || !currentGame) return;

            if (!canPerformTrade()) {
                log('‚ùå Cannot perform trade right now');
                return;
            }

            if (targetPlayerId === 'TRADE_WITH_DECK') {
                log('üé¥ Special case: Trading with deck because dealer has King');
                socket.emit('trade-with-deck-special', {
                    gameId: currentGame.id
                });
                return;
            }

            // ENHANCED: Better logging for debugging
            const hasLooked = hasPlayerLooked(targetPlayerId);
            const targetPlayer = currentGame.players.find(p => p.id === targetPlayerId);
            const targetName = targetPlayer?.name || 'Player';

            log('üîç Trade check for ' + targetName + ': hasLooked=' + hasLooked + ', cardLooks=' + JSON.stringify(playerCardLooks));

            if (!hasLooked) {
                log('üîî ' + targetName + ' must look at their card first!');
                showToast(targetName + ' must look at their card first! üëÜ', 'warning');
                startNudge(targetPlayerId, targetName + ', look at your card before trade!');
                return;
            }

            log('üîÑ Requesting trade: ' + playerId + ' ‚Üí ' + targetPlayerId);

            socket.emit('trade-request', {
                gameId: currentGame.id,
                targetPlayerId
            });
        }

        function endRound() {
            if (!socket || !currentGame) return;
            socket.emit('end-round', { gameId: currentGame.id });
            log('‚è∞ Ending round...');
        }

        function leaveGame() {
            if (confirm('Are you sure you want to leave the game?')) {
                leaveVideoCall().catch(console.error);
                completeCleanup();
                showMainMenu();
                log('üö™ Left game and cleaned up completely');
            }
        }

        // Chat functions
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();

            if (message && socket) {
                socket.emit('game-chat', {
                    gameId: currentGame.id,
                    message
                });
                chatInput.value = '';
            }
        }

        // Video integration (add your Agora token)
        function initializeVideoCall() {
            if (isVideoJoined) return;

            log('üìπ Initializing video call...');

            // Check if Agora SDK is loaded
            if (typeof AgoraRTC === 'undefined') {
                log('‚ùå Agora SDK not loaded - video features disabled');
                showToast('Video features unavailable - Agora SDK not loaded', 'warning');
                return;
            }

            try {
                agoraClient = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
                log('üìπ Agora client created successfully');

                agoraClient.on("user-published", handleUserPublished);
                agoraClient.on("user-unpublished", handleUserUnpublished);
                agoraClient.on("user-left", handleUserLeft);
                log('üìπ Event listeners added');

                joinVideoChannel();
            } catch (error) {
                log('‚ùå Error initializing video: ' + error.message);
                showToast('Video initialization failed - continuing without video', 'warning');
            }
        }

        async function joinVideoChannel() {
            try {
                const channelName = currentGame?.gameCode || currentGame?.id || 'test123';
                const uid = playerId; // Use socket ID instead of random number
                const appId = '6dc9368154fd49b3b0543e2a99dbee24'; // Add your app ID here

                if (appId === 'YOUR_AGORA_APP_ID') {
                    log('‚ùå Agora App ID not configured - video disabled');
                    showToast('Video disabled: Configure Agora App ID', 'warning');
                    return;
                }

                log('üìπ Attempting to join channel: ' + channelName);

                await agoraClient.join(appId, channelName, null, uid);
                log('üìπ Successfully joined channel');

                try {
                    localVideoTrack = await AgoraRTC.createCameraVideoTrack();
                    localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                    log('üìπ Media tracks created');

                    const myVideoElement = document.getElementById('video-' + playerId);
                    if (myVideoElement && localVideoTrack) {
                        localVideoTrack.play(myVideoElement);
                        const placeholder = myVideoElement.querySelector('.video-placeholder');
                        if (placeholder) placeholder.remove();
                    }

                    await agoraClient.publish([localVideoTrack, localAudioTrack]);
                    log('üìπ Tracks published successfully');

                    isVideoJoined = true;
                    log('üìπ Video call started successfully');

                } catch (mediaError) {
                    log('‚ùå Media error: ' + mediaError.message);
                    showToast('Camera/microphone access denied - video disabled', 'warning');
                }

            } catch (error) {
                log('‚ùå Error joining video channel: ' + error.message);
                showToast('Failed to join video call - continuing without video', 'warning');
            }
        }

        // FIXED: Properly defined handleUserPublished function
        async function handleUserPublished(user, mediaType) {
            try {
                log('üìπ ' + user.uid + ' started ' + mediaType);
                await agoraClient.subscribe(user, mediaType);

                if (mediaType === 'video') {
                    const videoElement = document.getElementById('video-' + user.uid);
                    if (videoElement && user.videoTrack) {
                        user.videoTrack.play(videoElement);
                        const placeholder = videoElement.querySelector('.video-placeholder');
                        if (placeholder) placeholder.remove();
                    }
                }

                remoteUsers[user.uid] = user;
            } catch (error) {
                log('‚ùå Error handling user published: ' + error.message);
            }
        }

        function handleUserUnpublished(user, mediaType) {
            log('üìπ ' + user.uid + ' stopped ' + mediaType);

            if (mediaType === 'video') {
                const videoElement = document.getElementById('video-' + user.uid);
                if (videoElement) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'video-placeholder';
                    placeholder.textContent = 'üìπ';
                    videoElement.innerHTML = '';
                    videoElement.appendChild(placeholder);
                }
            }
        }

        function handleUserLeft(user) {
            log('üëã ' + user.uid + ' left video call');
            delete remoteUsers[user.uid];

            const videoElement = document.getElementById('video-' + user.uid);
            if (videoElement) {
                const placeholder = document.createElement('div');
                placeholder.className = 'video-placeholder';
                placeholder.textContent = 'üìπ';
                videoElement.innerHTML = '';
                videoElement.appendChild(placeholder);
            }
        }

        function initializeVideoForPlayer(playerId) {
            const remoteUser = remoteUsers[playerId];
            if (remoteUser && remoteUser.videoTrack) {
                const videoElement = document.getElementById('video-' + playerId);
                if (videoElement) {
                    remoteUser.videoTrack.play(videoElement);
                    const placeholder = videoElement.querySelector('.video-placeholder');
                    if (placeholder) placeholder.remove();
                }
            }
        }

        async function leaveVideoCall() {
            if (!isVideoJoined) return;

            try {
                log('üìπ Leaving video call...');

                if (localVideoTrack) {
                    localVideoTrack.stop();
                    localVideoTrack.close();
                }

                if (localAudioTrack) {
                    localAudioTrack.stop();
                    localAudioTrack.close();
                }

                if (agoraClient) {
                    await agoraClient.leave();
                }

                isVideoJoined = false;
                remoteUsers = {};
                log('üìπ Left video call');

            } catch (error) {
                log('‚ùå Error leaving video call: ' + error.message);
            }
        }

        // Complete cleanup function
        function completeCleanup() {
            log('üßπ Performing complete cleanup...');

            // Force clear any stored reconnection data
            localStorage.removeItem('gameReconnectData');

            // Clear any mobile reconnection flags
            if (window.reconnectOnForeground) {
                window.reconnectOnForeground = false;
            }

            // 1. Disconnect socket completely
            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
                socket = null;
            }

            // 2. Clear ALL game state
            currentGame = null;
            playerId = null;
            lastGameState = null;

            // 3. Reinitialize focus state completely
            initializeFocusState();

            // 4. Clear video state
            videoStates = {};
            remoteUsers = {};
            isVideoJoined = false;

            // 5. Clear gesture and King logic state
            playerCardLooks = {};
            gestureState = {
                startX: 0,
                startY: 0,
                startTime: 0,
                isTracking: false,
                element: null,
                lastTap: 0
            };
            clearAllNudges();

            // 6. Clear all UI elements
            const focusGrid = document.getElementById('focusGrid');
            if (focusGrid) focusGrid.innerHTML = '';

            const playersScroll = document.getElementById('playersScroll');
            if (playersScroll) playersScroll.innerHTML = '';

            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages) chatMessages.innerHTML = '';

            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages) gameMessages.innerHTML = '';

            // 7. Reset connection status
            const connectionStatus = document.getElementById('connectionStatus');
            if (connectionStatus) connectionStatus.innerHTML = 'üî¥ Disconnected';

            // 8. Clear any timeouts
            if (updateTimeout) {
                clearTimeout(updateTimeout);
                updateTimeout = null;
            }

            log('üßπ Complete cleanup finished');
        }

        // Menu navigation
        function showMainMenu() {
            completeCleanup();
            document.querySelectorAll('.menu-screen, #gameContent').forEach(el => el.classList.add('hidden'));
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function showQuickMatch() {
            completeCleanup();
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('quick-match').classList.remove('hidden');

            setTimeout(() => {
                connectToServer();
                setTimeout(() => {
                    createPublicGame();
                }, 1000);
            }, 100);
        }

        function showCreateGame() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('create-game').classList.remove('hidden');
        }

        function showJoinGame() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('join-game').classList.remove('hidden');
        }

        function showGameContent() {
            document.querySelectorAll('.menu-screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('gameContent').classList.remove('hidden');
        }

        // Server connection
        function connectToServer() {
            log('üîÑ Creating FRESH server connection...');

            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
                socket = null;
            }

            // Connect to your backend server on port 3001
            const serverUrl = window.location.hostname === 'localhost' ?
                'http://localhost:3001' :
                window.location.origin;

            socket = io(serverUrl, {
                transports: ['websocket', 'polling'],
                timeout: 60000,
                reconnection: true,
                reconnectionDelay: 3000,
                reconnectionAttempts: 15,
                maxReconnectionAttempts: 15,
                reconnectionDelayMax: 15000,
                randomizationFactor: 0.5,
                forceNew: true,
                pingTimeout: 90000,
                pingInterval: 30000,
                upgradeTimeout: 45000
            });

            // ===== ALL SOCKET EVENT HANDLERS INSIDE FUNCTION =====
            socket.on('connect', () => {
                log('‚úÖ FRESH connection established! ID: ' + socket.id);
                document.getElementById('connectionStatus').innerHTML = 'üü¢ Connected';

                playerName = document.getElementById('playerName').value || 'Player';
                if (playerId && currentGame) {
                    log('üîÑ Checking for reconnection...');
                    socket.emit('check-reconnect', { userId: playerId });
                } else {
                    playerId = socket.id;
                }
            });

            socket.on('disconnect', (reason) => {
                log('‚ùå Disconnected: ' + reason);
                document.getElementById('connectionStatus').innerHTML = 'üî¥ Disconnected';
                if (isVideoJoined) {
                    leaveVideoCall().catch(console.error);
                }
            });

            socket.on('connect_error', (error) => {
                log('‚ùå Connection error: ' + error.message);
                showToast('Connection failed. Make sure server is running on port 3001.', 'error');
            });

            // ===== GAME CREATION & JOINING EVENTS =====
            socket.on('public-game-created', function (data) {
                log('üéÆ FRESH public game created! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                showHostControls();
            });

            socket.on('game-joined', function (data) {
                log('üéÆ Joined game! ID: ' + data.game.id);
                currentGame = data.game;
                showGameContent();
                updateGameDisplay();
                updatePersonalTable();
                if (currentGame.hostId === playerId) {
                    showHostControls();
                }
            });

            socket.on('player-joined', function (data) {
                log('üëã Player joined: ' + (data.newPlayer?.name || 'Unknown'));
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('game-started', function (data) {
                log('üéÆ Game started!');
                currentGame = data.game;
                resetCardLooks();
                clearAllNudges();
                hideHostControls();
                updateGameDisplay();
                updatePersonalTable();
                setTimeout(() => {
                    initializeVideoCall();
                }, 1000);
            });

            socket.on('cards-dealt', function (data) {
                log('üé¥ Cards dealt!');
                currentGame = data.game;
                resetCardLooks();
                clearAllNudges();
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('turn-skipped', function (data) {
                log('‚è≠Ô∏è Player skipped turn');
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('card-flipped', function (data) {
                log('üé¥ Player flipped card');
                currentGame = data.game;

                // ADDED: Track when ANY player flips their card
                if (data.playerId) {
                    markPlayerAsLooked(data.playerId);
                    log('üëÅÔ∏è Marked player ' + data.playerId + ' as looked via card-flipped event');
                }

                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('trade-completed', function (data) {
                log('‚úÖ Trade completed!');
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
                showToast('Trade completed!', 'success');
            });

            socket.on('jack-blocked-trade', function (data) {
                log('üÉè Jack blocked trade: ' + data.toPlayerId + ' blocks ' + data.fromPlayerId);
                currentGame = data.game;
                handleJackBlock(data);
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('dealer-traded-deck', function (data) {
                log('üé¥ Dealer deck trade completed!');
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
                showToast('Dealer traded with deck!', 'success');
            });

            socket.on('cards-revealed', function (data) {
                log('üÉè Cards revealed for round end');
                currentGame = data.game;
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('round-ended', function (data) {
                log('üèÅ Round ended');

                if (data.result && data.result.losers) {
                    data.result.losers.forEach(loser => {
                        log('üíÄ ' + loser.name + ' lost with ' + loser.card?.value + loser.card?.suit);
                    });
                }

                currentGame = data.game;
                resetCardLooks();
                clearAllNudges();
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('game-finished', function (data) {
                log('Game finished!');
                currentGame = data.game;
                if (data.winner) {
                    showToast('üèÜ ' + data.winner.name + ' Wins!', 'success');
                }
                updateGameDisplay();
                updatePersonalTable();
            });

            socket.on('chat-message', function (data) {
                addChatMessage(data.playerName || 'Unknown', data.message);
            });

            socket.on('error', function (data) {
                log('‚ùå Error: ' + data.message);
                showToast(data.message, 'error');
            });
        }

        // Game creation with validation
        function createPublicGame() {
            if (!socket || !socket.connected) {
                log('‚ùå No socket connection - reconnecting...');
                connectToServer();
                setTimeout(createPublicGame, 1000);
                return;
            }

            const rawPlayerName = document.getElementById('playerName').value.trim() || 'Player';

            // Validate username
            if (!validatePlayerName(rawPlayerName)) {
                return;
            }

            playerName = rawPlayerName;

            // Check if already in a game with this name
            if (checkForDuplicateUsername(playerName)) {
                return;
            }

            log('üéÆ Creating FRESH public game for ' + playerName + ' (' + socket.id + ')');

            socket.emit('quick-match', {
                playerName: playerName,
                userId: socket.id,
                token: 'demo_token_' + socket.id
            });
        }

        function createPrivateGame() {
            if (!socket) {
                connectToServer();
                setTimeout(createPrivateGame, 1000);
                return;
            }

            const rawPlayerName = document.getElementById('playerName').value.trim() || 'Player';

            // Validate username
            if (!validatePlayerName(rawPlayerName)) {
                return;
            }

            playerName = rawPlayerName;

            const settings = {
                startingLives: parseInt(document.getElementById('startingLives').value),
                deckCount: parseInt(document.getElementById('deckCount').value),
                tournamentMode: 'single',
                cardStyle: 'classic'
            };

            socket.emit('create-private-game', {
                playerName: playerName,
                userId: socket.id,
                token: 'demo_token_' + socket.id,
                settings: settings
            });
        }

        function joinGame() {
            const gameCode = document.getElementById('gameCode').value.trim().toUpperCase();
            if (!gameCode) {
                showToast('Please enter a game code', 'error');
                return;
            }

            if (!socket) {
                connectToServer();
                setTimeout(() => joinGame(), 1000);
                return;
            }

            const rawPlayerName = document.getElementById('playerName').value.trim() || 'Player';

            // Validate username
            if (!validatePlayerName(rawPlayerName)) {
                return;
            }

            playerName = rawPlayerName;

            socket.emit('join-game', {
                friendCode: gameCode,
                playerName: playerName,
                userId: socket.id,
                token: 'demo_token_' + socket.id
            });
        }

        // Game display updates
        function updateGameDisplay() {
            if (!currentGame) return;

            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }

            updateTimeout = setTimeout(() => {
                performGameDisplayUpdate();
            }, 50);
        }

        function performGameDisplayUpdate() {
            if (!currentGame) return;

            document.getElementById('gameCodeDisplay').innerHTML = 'Game: <strong>' + (currentGame.gameCode || currentGame.id || 'UNKNOWN') + '</strong>';
            document.getElementById('playerCount').innerHTML = 'Players: <strong>' + (currentGame.players?.length || 0) + '/' + (currentGame.maxPlayers || 8) + '</strong>';

            updateButtonStates();
        }

        function updateButtonStates() {
            if (!currentGame) return;

            const myPlayer = currentGame.players?.find(p => p.id === playerId);
            const isMyTurn = currentGame.currentPlayerId === playerId;
            const gameStarted = currentGame.state === 'playing';
            const canEndRound = gameStarted && currentGame.turnPhase === 'revealing';
            const canTrade = canPerformTrade();

            // Detect if I'm the dealer and it's my turn (final turn of round)
            const isDealer = myPlayer && myPlayer.id === currentGame?.dealerId;
            const isDealerTurn = isDealer && isMyTurn && gameStarted;

            // Main control buttons
            const flipBtn = document.getElementById('flipCardBtn');
            const keepBtn = document.getElementById('keepCardBtn');
            const tradeBtn = document.getElementById('tradeCardBtn');
            const endBtn = document.getElementById('endRoundBtn');

            if (flipBtn) {
                flipBtn.disabled = !gameStarted || !myPlayer || !myPlayer.hasCard;
                flipBtn.style.opacity = flipBtn.disabled ? '0.5' : '1';
            }
            if (keepBtn) {
                // Update button text for dealer
                if (isDealerTurn) {
                    keepBtn.textContent = '‚úã Keep & End Round';
                    keepBtn.style.background = '#f39c12'; // Orange for dealer
                } else {
                    keepBtn.textContent = '‚úã Keep Card';
                    keepBtn.style.background = '#27ae60'; // Green for normal
                }
                keepBtn.disabled = !isMyTurn || !gameStarted;
                keepBtn.style.opacity = keepBtn.disabled ? '0.5' : '1';
            }
            if (tradeBtn) {
                // Update button text for dealer
                if (isDealerTurn) {
                    tradeBtn.textContent = 'üé¥ Trade w/ Deck';
                    tradeBtn.style.background = '#e74c3c'; // Red for dealer deck trade
                } else {
                    tradeBtn.textContent = 'üîÑ Trade Card';
                    tradeBtn.style.background = '#3498db'; // Blue for normal trade
                }
                tradeBtn.disabled = !canTrade && !isDealerTurn;
                tradeBtn.style.opacity = tradeBtn.disabled ? '0.5' : '1';
            }
            if (endBtn) {
                endBtn.disabled = !canEndRound;
                endBtn.style.opacity = endBtn.disabled ? '0.5' : '1';
            }

            // Update all card action buttons
            document.querySelectorAll('.action-button').forEach(btn => {
                if (btn.textContent.includes('Keep')) {
                    btn.disabled = !isMyTurn || !gameStarted;
                    btn.style.opacity = btn.disabled ? '0.5' : '1';

                    // Update card-level button text for dealer
                    if (isDealerTurn) {
                        btn.textContent = '‚úã Keep & End';
                        btn.style.background = '#f39c12';
                    } else {
                        btn.textContent = '‚úã Keep';
                        btn.style.background = '#27ae60';
                    }
                }
                if (btn.textContent.includes('Trade')) {
                    btn.disabled = !canTrade && !isDealerTurn;
                    btn.style.opacity = btn.disabled ? '0.5' : '1';

                    // Update card-level button text for dealer
                    if (isDealerTurn) {
                        btn.textContent = 'üé¥ Deck';
                        btn.style.background = '#e74c3c';
                    } else {
                        btn.textContent = 'üîÑ Trade';
                        btn.style.background = '#3498db';
                    }
                }
            });

            log('üîÑ Button states updated: myTurn=' + isMyTurn + ', gameStarted=' + gameStarted + ', phase=' + currentGame.turnPhase + ', canTrade=' + canTrade + ', isDealerTurn=' + isDealerTurn);
        }

        function showHostControls() {
            if (currentGame?.hostId === playerId && currentGame?.state === 'waiting') {
                document.getElementById('hostControls')?.classList.remove('hidden');
            }
        }

        function hideHostControls() {
            document.getElementById('hostControls')?.classList.add('hidden');
        }

        // Enhanced Jack block handling with auto-advance
        function handleJackBlock(data) {
                log('üÉè JACK BLOCKED! Data received:', JSON.stringify(data));

                const fromPlayerId = data.fromPlayerId;
                const toPlayerId = data.toPlayerId;

                if (!fromPlayerId || !toPlayerId) {
                    log('‚ùå Invalid Jack block data - missing player IDs');
                    return;
                }

                // Find the actual player objects from the game state
                const fromPlayer = currentGame?.players?.find(p => p.id === fromPlayerId);
                const toPlayer = currentGame?.players?.find(p => p.id === toPlayerId);

            if (!fromPlayer || !toPlayer) {
                log('‚ùå Could not find players for Jack block: ' + fromPlayerId + ' -> ' + toPlayerId);
                return;
            }

            log('üÉè ' + toPlayer.name + ' Jack blocks ' + fromPlayer.name + ' - SCREW YOU!');

            // 1. Mark the Jack holder as having revealed their card to everyone
            toPlayer.cardRevealed = true;
            markPlayerAsLooked(toPlayer.id);

            // 2. Show dramatic "SCREW YOU!" message
            showJackScrewYouMessage(fromPlayer.name, toPlayer.name);

            // 3. Add special Jack reveal animation to the card
            setTimeout(() => {
                addJackRevealAnimation(toPlayer.id);
            }, 100);

            // 4. Show toast notification
            showToast(toPlayer.name + ' blocks with a Jack! üÉè', 'warning');

            // 5. Auto-advance logic - monitor for Jack holder's turn
            log('üÉè Setting up auto-advance monitor for Jack holder ' + toPlayer.name);

            // Set up a monitoring function that will auto-advance when it becomes the Jack holder's turn
            const jackAutoAdvanceMonitor = () => {
                // Check if it's now the Jack holder's turn
                if (currentGame?.currentPlayerId === toPlayer.id && currentGame?.state === 'playing') {
                    log('üÉè Jack holder ' + toPlayer.name + '\'s turn detected - auto-advancing!');

                    // Auto-advance after animation completes
                    setTimeout(() => {
                        if (socket && currentGame && currentGame.currentPlayerId === toPlayer.id) {
                            log('üÉè Emitting skip-turn for Jack holder ' + toPlayer.name);
                            socket.emit('skip-turn', { gameId: currentGame.id });
                            showToast(toPlayer.name + '\'s Jack auto-advances! üÉè', 'success');
                        } else {
                            log('üÉè Conditions changed - not auto-advancing Jack holder');
                        }
                    }, 1000); // Shorter delay since they already saw the animation

                    // Clear the monitor
                    clearInterval(monitorInterval);
                }
            };

            // Start monitoring for the Jack holder's turn (check every 500ms for up to 10 seconds)
            const monitorInterval = setInterval(jackAutoAdvanceMonitor, 500);

            // Safety cleanup after 10 seconds
            setTimeout(() => {
                clearInterval(monitorInterval);
                log('üÉè Jack auto-advance monitor cleanup for ' + toPlayer.name);
            }, 10000);
        }

        // Flying spinning Jack card animation
        function showJackScrewYouMessage(blockedPlayerName, jackPlayerName) {
            // Step 1: Find the Jack holder's card to get its position
            const jackPlayer = currentGame?.players?.find(p => p.name === jackPlayerName);
            if (!jackPlayer) {
                // Fallback to original overlay if we can't find the player
                showOriginalScrewYouOverlay(blockedPlayerName, jackPlayerName);
                return;
            }

            const jackCardElement = document.querySelector('[data-player-id="' + jackPlayer.id + '"] .card-display');
            if (!jackCardElement) {
                // Fallback to original overlay if we can't find the card
                showOriginalScrewYouOverlay(blockedPlayerName, jackPlayerName);
                return;
            }

            // Step 2: Get the card's current position
            const cardRect = jackCardElement.getBoundingClientRect();
            const startX = cardRect.left + cardRect.width / 2;
            const startY = cardRect.top + cardRect.height / 2;

            // Step 3: Create the flying Jack card
            const flyingJack = document.createElement('div');
            flyingJack.className = 'flying-jack-card';
            flyingJack.style.cssText = 'position: fixed; left: ' + (startX - 40) + 'px; top: ' + (startY - 55) + 'px; width: 80px; height: 110px; background: linear-gradient(145deg, #ffffff, #f8f8f8); border: 2px solid #ddd; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #333; font-weight: bold; font-family: \'Times New Roman\', serif; font-size: 1rem; box-shadow: 0 4px 8px rgba(0,0,0,0.3); z-index: 1001; pointer-events: none; animation: jackFlyOut 2.5s ease-out forwards;';

            // Step 4: Add the Jack card content
            const jackCard = jackPlayer.card;
            if (jackCard) {
                const isRed = jackCard.suit === '‚ô•' || jackCard.suit === '‚ô¶';
                if (isRed) {
                    flyingJack.style.color = '#d32f2f';
                }

                flyingJack.innerHTML = '<div style="font-size: 1.1rem; margin-bottom: 2px;">' + jackCard.value + '</div><div style="font-size: 1.3rem;">' + jackCard.suit + '</div>';
            } else {
                // Fallback Jack content
                flyingJack.innerHTML = '<div style="font-size: 1.1rem; margin-bottom: 2px;">J</div><div style="font-size: 1.3rem;">‚ô†</div>';
            }

            // Step 5: Add the flying card to the page
            document.body.appendChild(flyingJack);

            // Step 6: Add "SCREW YOU!" text directly on the landed card
            setTimeout(() => {
                addScrewYouTextToCard(flyingJack, blockedPlayerName, jackPlayerName);
            }, 2500); // Wait for the card animation to complete
        }

        // Original overlay function (fallback)
        function showOriginalScrewYouOverlay(blockedPlayerName, jackPlayerName) {
            // Create big dramatic overlay
            const screwYouOverlay = document.createElement('div');
            screwYouOverlay.className = 'jack-screw-you-overlay';
            screwYouOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; animation: jackRevealBurst 0.6s ease-out; pointer-events: none;';

            const screwYouContent = document.createElement('div');
            screwYouContent.style.cssText = 'background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; padding: 30px 50px; border-radius: 15px; text-align: center; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); border: 4px solid #fff; animation: jackBounceIn 0.8s ease-out;';

            screwYouContent.innerHTML = '<h1 style="font-size: 3rem; margin: 0 0 15px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">üÉè</h1><h2 style="font-size: 2.5rem; margin: 0 0 10px 0; font-weight: bold;">SCREW YOU!</h2><p style="font-size: 1.3rem; margin: 0; opacity: 0.9;">' + jackPlayerName + ' blocks ' + blockedPlayerName + '!</p>';

            screwYouOverlay.appendChild(screwYouContent);
            document.body.appendChild(screwYouOverlay);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (screwYouOverlay.parentNode) {
                    screwYouOverlay.style.animation = 'fadeOut 0.5s ease-out';
                    setTimeout(() => {
                        screwYouOverlay.remove();
                    }, 500);
                }
            }, 2500);
        }

        // Jack card animation
        function addJackRevealAnimation(playerId) {
            const playerCard = document.querySelector('[data-player-id="' + playerId + '"] .card-display');
            if (!playerCard) return;

            log('üÉè Adding Jack reveal animation for player ' + playerId);

            // Add special Jack blocking animation class
            playerCard.classList.add('jack-block-reveal');

            // Remove animation class after it completes
            setTimeout(() => {
                playerCard.classList.remove('jack-block-reveal');
            }, 2000);
        }

        // Add "SCREW YOU!" text to the landed card
        function addScrewYouTextToCard(flyingJack, blockedPlayerName, jackPlayerName) {
            log('üÉè Adding text to card...');

            // Create simple text overlay
            const textOverlay = document.createElement('div');
            textOverlay.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(231, 76, 60, 0.95); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; font-weight: bold; text-align: center; z-index: 1002;';

            textOverlay.innerHTML = '<div style="font-size: 1.4rem; margin-bottom: 5px;">üí•</div><div style="font-size: 1.2rem; line-height: 1.2;">YOU GOT<br>SCREWED!</div>';

            // Add text to card
            flyingJack.appendChild(textOverlay);
            log('üÉè Text added to card');

            // FORCE remove after 3 seconds - no matter what
            setTimeout(() => {
                log('üÉè Removing card now...');
                if (flyingJack && flyingJack.parentNode) {
                    flyingJack.remove();
                }
            }, 3000);
        }

        // Emergency function to clear stuck cards
        function clearStuckCard() {
            const stuckCards = document.querySelectorAll('.flying-jack-card');
            stuckCards.forEach(card => card.remove());
            log('üßπ Cleared stuck cards');
            showToast('Cleared stuck card!', 'success');
        }

        // Winner announcement with auto-continue
        function showWinnerAnnouncement(winnerName) {
            // Create big winner overlay
            const winnerOverlay = document.createElement('div');
            winnerOverlay.className = 'winner-announcement';
            winnerOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; animation: fadeIn 0.5s ease;';

            const winnerContent = document.createElement('div');
            winnerContent.style.cssText = 'background: linear-gradient(45deg, #f39c12, #e67e22); color: white; padding: 40px 60px; border-radius: 20px; text-align: center; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); animation: bounceIn 0.6s ease;';

            winnerContent.innerHTML = '<h1 style="font-size: 3rem; margin: 0 0 20px 0;">üèÜ</h1><h2 style="font-size: 2rem; margin: 0 0 10px 0;">' + winnerName + ' Wins!</h2><p style="font-size: 1.2rem; margin: 0 0 10px 0; opacity: 0.9;">Congratulations!</p><div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px; margin: 20px 0;"><h3 style="font-size: 1.4rem; margin: 0 0 10px 0;">üöÄ Next game starting in...</h3><div id="countdownTimer" style="font-size: 3rem; font-weight: bold; margin: 10px 0;">15</div><div id="playersReady" style="font-size: 1.1rem; margin: 10px 0; opacity: 0.9;">3/3 players ready</div></div><div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;"><button onclick="stayForNextGame()" style="padding: 12px 24px; background: #27ae60; border: 2px solid white; color: white; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.background=\'#2ecc71\'" onmouseout="this.style.background=\'#27ae60\'">‚úÖ I\'m Ready!</button><button onclick="leaveAfterGame()" style="padding: 12px 24px; background: #e74c3c; border: 2px solid white; color: white; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.background=\'#c0392b\'" onmouseout="this.style.background=\'#e74c3c\'">üö™ Leave Game</button></div>';

            winnerOverlay.appendChild(winnerContent);
            document.body.appendChild(winnerOverlay);

            // Start the auto-continue countdown
            startAutoContinueCountdown();
        }

        // Tie game announcement
        function showTieAnnouncement(tiedPlayers) {
            const tieOverlay = document.createElement('div');
            tieOverlay.className = 'tie-announcement';
            tieOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; animation: fadeIn 0.5s ease;';

            const tieContent = document.createElement('div');
            tieContent.style.cssText = 'background: linear-gradient(45deg, #9b59b6, #8e44ad); color: white; padding: 40px 60px; border-radius: 20px; text-align: center; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); animation: bounceIn 0.6s ease;';

            const tiedPlayerNames = tiedPlayers.map(p => p.name).join(' & ');

            tieContent.innerHTML = '<h1 style="font-size: 3rem; margin: 0 0 20px 0;">ü§ù</h1><h2 style="font-size: 2rem; margin: 0 0 10px 0;">TIE GAME!</h2><p style="font-size: 1.2rem; margin: 0 0 20px 0; opacity: 0.9;">' + tiedPlayerNames + ' tied for the win!</p><button onclick="closeWinnerAnnouncement(); leaveGame();" style="padding: 15px 30px; background: #e74c3c; border: 2px solid white; color: white; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.background=\'#c0392b\'" onmouseout="this.style.background=\'#e74c3c\'">üö™ Leave Game</button>';

            tieOverlay.appendChild(tieContent);
            document.body.appendChild(tieOverlay);
        }

        // Auto-continue countdown system
        function startAutoContinueCountdown() {
            log('üöÄ Starting auto-continue countdown...');

            // Reset state
            countdownSeconds = 15;
            playersReadyForNext.clear();

            // Add myself as ready by default (auto-opt-in)
            playersReadyForNext.add(playerId);

            // Emit to server that auto-continue started
            if (socket && currentGame) {
                socket.emit('auto-continue-started', {
                    gameId: currentGame.id,
                    playerId: playerId,
                    ready: true
                });
            }

            // Update display immediately
            updateAutoContinueDisplay();

            // Start countdown timer
            autoContinueTimer = setInterval(() => {
                countdownSeconds--;
                updateAutoContinueDisplay();

                if (countdownSeconds <= 0) {
                    clearInterval(autoContinueTimer);
                    triggerAutoContinue();
                }
            }, 1000);
        }

        function updateAutoContinueDisplay() {
            const timerElement = document.getElementById('countdownTimer');
            const readyElement = document.getElementById('playersReady');

            if (timerElement) {
                timerElement.textContent = countdownSeconds;
                // Add urgency colors
                if (countdownSeconds <= 5) {
                    timerElement.style.color = '#e74c3c'; // Red
                } else if (countdownSeconds <= 10) {
                    timerElement.style.color = '#f39c12'; // Orange
                }
            }

            if (readyElement && currentGame) {
                const totalPlayers = currentGame.players.length;
                const readyCount = playersReadyForNext.size;
                readyElement.textContent = readyCount + '/' + totalPlayers + ' players ready';

                // Green when everyone ready
                if (readyCount === totalPlayers) {
                    readyElement.style.color = '#2ecc71';
                    readyElement.textContent += ' üéâ';
                }
            }
        }

        function stayForNextGame() {
            log('‚úÖ Player confirmed ready for next game');

            // Add to ready set
            playersReadyForNext.add(playerId);

            // Emit to server
            if (socket && currentGame) {
                socket.emit('auto-continue-ready', {
                    gameId: currentGame.id,
                    playerId: playerId,
                    ready: true
                });
            }

            // Update display
            updateAutoContinueDisplay();

            // Visual feedback
            showToast('Ready for next game! üöÄ', 'success');

            // Disable ready button, enable leave button
            const readyBtn = event.target;
            readyBtn.style.background = '#2ecc71';
            readyBtn.textContent = '‚úÖ Ready!';
            readyBtn.disabled = true;
        }

        function leaveAfterGame() {
            log('üö™ Player choosing to leave after game');

            // Remove from ready set
            playersReadyForNext.delete(playerId);

            // Emit to server
            if (socket && currentGame) {
                socket.emit('auto-continue-ready', {
                    gameId: currentGame.id,
                    playerId: playerId,
                    ready: false
                });
            }

            // Stop the countdown and leave
            if (autoContinueTimer) {
                clearInterval(autoContinueTimer);
            }

            // Clean exit
            closeWinnerAnnouncement();
            completeCleanup();
            showMainMenu();

            showToast('Thanks for playing! üëã', 'success');
        }

        function triggerAutoContinue() {
            log('üöÄ Auto-continue timer finished - starting next game!');

            // Close winner screen
            closeWinnerAnnouncement();

            // Check if enough players ready
            if (playersReadyForNext.size >= 2) {
                // Start new game with ready players
                if (socket && currentGame) {
                    socket.emit('start-auto-continue', {
                        gameId: currentGame.id,
                        readyPlayers: Array.from(playersReadyForNext)
                    });
                }
                showToast('üöÄ New game starting with ready players!', 'success');
            } else {
                // Not enough players - return to main menu
                completeCleanup();
                showMainMenu();
                showToast('Not enough players for next game', 'warning');
            }
        }

        function closeWinnerAnnouncement() {
            const overlay = document.querySelector('.winner-announcement, .tie-announcement');
            if (overlay) {
                overlay.remove();
            }
        }

        function disableAllGameButtons() {
            // Disable main control buttons
            document.getElementById('flipCardBtn').disabled = true;
            document.getElementById('keepCardBtn').disabled = true;
            document.getElementById('tradeCardBtn').disabled = true;
            document.getElementById('endRoundBtn').disabled = true;

            // Hide start game button if visible
            const hostControls = document.getElementById('hostControls');
            if (hostControls) {
                hostControls.classList.add('hidden');
            }

            // Disable all card action buttons
            document.querySelectorAll('.action-button').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.3';
            });

            log('üîí All game buttons disabled - game finished');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            completeCleanup();
            if (socket) {
                socket.removeAllListeners();
                socket.disconnect();
            }
            if (isVideoJoined) {
                leaveVideoCall().catch(console.error);
            }
        });

        // üé• VIDEO RESTORATION HELPER FUNCTIONS
        function restoreVideoStreams(videoStreams) {
            log('üé• Restoring ' + videoStreams.size + ' video streams...');

            videoStreams.forEach((streamData, videoId) => {
                const newVideoElement = document.getElementById(videoId);
                if (newVideoElement && streamData.hasContent) {
                    // Clear placeholder
                    newVideoElement.innerHTML = '';

                    // Restore the video content
                    Array.from(streamData.element.children).forEach(child => {
                        newVideoElement.appendChild(child.cloneNode(true));
                    });

                    log('‚úÖ Restored video stream: ' + videoId);
                }
            });

            // Reconnect Agora streams
            reconnectAgoraStreams();
        }

        function reconnectAgoraStreams() {
            if (!isVideoJoined) return;

            log('üé• Reconnecting Agora streams...');

            // Reconnect local video
            if (localVideoTrack) {
                const myVideoElement = document.getElementById('video-' + playerId);
                if (myVideoElement) {
                    try {
                        localVideoTrack.play(myVideoElement);
                        log('‚úÖ Reconnected local video: video-' + playerId);
                    } catch (error) {
                        log('‚ùå Error reconnecting local video: ' + error.message);
                    }
                }
            }

            // Reconnect remote videos
            Object.keys(remoteUsers).forEach(uid => {
                const user = remoteUsers[uid];
                if (user && user.videoTrack) {
                    const videoElement = document.getElementById('video-' + uid);
                    if (videoElement) {
                        try {
                            user.videoTrack.play(videoElement);
                            log('‚úÖ Reconnected remote video: video-' + uid);
                        } catch (error) {
                            log('‚ùå Error reconnecting video for ' + uid + ': ' + error.message);
                        }
                    }
                }
            });
        }

        function getCurrentLayoutSnapshot() {
            if (!focusedPlayers) return null;
            return {
                leftNeighbor: focusedPlayers.leftNeighbor?.id || null,
                currentTurn: focusedPlayers.currentTurn?.id || null,
                rightNeighbor: focusedPlayers.rightNeighbor?.id || null,
                custom1: focusedPlayers.custom1?.id || null,
                custom2: focusedPlayers.custom2?.id || null
            };
        }

        function layoutChanged(oldLayout, newLayout) {
            if (!oldLayout || !newLayout) return true;

            return oldLayout.leftNeighbor !== newLayout.leftNeighbor ||
                oldLayout.currentTurn !== newLayout.currentTurn ||
                oldLayout.rightNeighbor !== newLayout.rightNeighbor ||
                oldLayout.custom1 !== newLayout.custom1 ||
                oldLayout.custom2 !== newLayout.custom2;
        }

        function updateExistingPlayerStates() {
            if (!focusedPlayers) return;

            Object.values(focusedPlayers).forEach(player => {
                if (player) {
                    updateSinglePlayerState(player);
                }
            });
        }

        function updateSinglePlayerState(player) {
                const playerSlot = document.querySelector('[data-player-id="' + player.id + '"]')?.closest('.focus-slot');
                if (!playerSlot) return;

                // Update slot classes properly without breaking video
                playerSlot.classList.remove('current-turn', 'dealer', 'eliminated');
                playerSlot.classList.add('focus-slot', 'slot'); // Ensure base classes remain

                if (player.id === currentGame?.currentPlayerId) {
                    playerSlot.classList.add('current-turn');
                }
                if (player.id === currentGame?.dealerId) {
                    playerSlot.classList.add('dealer');
                }
                if (player.lives <= 0) {
                    playerSlot.classList.add('eliminated');
                }

                // Update card display
                const cardDisplay = playerSlot.querySelector('.card-display');
                if (cardDisplay && player) {
                    updateCardDisplayOnly(cardDisplay, player);
                }

                // Update dealer text label AND life dots
            const existingPlayerInfo = playerSlot.querySelector('.player-info');
            if (existingPlayerInfo) {
                // Update dealer text first
                const playerNameSpan = existingPlayerInfo.querySelector('.player-name');
                if (playerNameSpan) {
                    const dealerText = (player.id === currentGame?.dealerId) ? ' (Dealer)' : '';
                    playerNameSpan.textContent = player.name + dealerText;
                }

                // Then update life dots
                const existingLives = existingPlayerInfo.querySelector('.player-lives-dots');
                if (existingLives) {
                    existingLives.remove();
                }
                const newLivesDisplay = createLivesDisplay(player, false);
                existingPlayerInfo.appendChild(newLivesDisplay);
            }

                // Update buttons
                updatePlayerButtonStates(playerSlot, player);
            }

        function updateCardDisplayOnly(cardDisplay, player) {
            const shouldShowCard = shouldPlayerCardBeVisible(player);

            if (player.card && shouldShowCard && player.lives > 0) {
                const card = player.card;
                const isRed = card.suit === '‚ô•' || card.suit === '‚ô¶';
                let cardClasses = 'card-display';
                cardClasses += isRed ? ' red revealed' : ' black revealed';

                if (isKing(card)) {
                    cardClasses += ' king-auto';
                }

                cardDisplay.className = cardClasses;
                cardDisplay.innerHTML = '<div class="card-content"><div class="card-value">' + card.value + '</div><div class="card-suit">' + card.suit + '</div></div>';
            } else if ((player.hasCard || player.card) && player.lives > 0) {
                cardDisplay.className = 'card-display face-down';
                cardDisplay.textContent = 'üÇ†';
            } else {
                cardDisplay.className = 'card-display';
                cardDisplay.textContent = 'No Card';
            }
        }

        function updatePlayerButtonStates(playerSlot, player) {
            // Update action buttons without recreating them
            const actionButtons = playerSlot.querySelectorAll('.action-button');
            const isMyTurn = currentGame?.currentPlayerId === player.id;
            const gameStarted = currentGame?.state === 'playing';

            actionButtons.forEach(btn => {
                if (btn.textContent.includes('Keep')) {
                    btn.disabled = !isMyTurn || !gameStarted;
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                }
                if (btn.textContent.includes('Trade')) {
                    const canTrade = canPerformTrade();
                    btn.disabled = !canTrade;
                    btn.style.opacity = btn.disabled ? '0.5' : '1';
                }
            });
        }

        // Initialize with clean state
        document.addEventListener('DOMContentLoaded', function () {
            log('üéÆ Game initialized with complete features!');

            initializeFocusState();

            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        sendChatMessage();
                    }
                });
            }

            // Add real-time username validation
            const playerNameInput = document.getElementById('playerName');
            if (playerNameInput) {
                playerNameInput.addEventListener('input', function (e) {
                    const name = e.target.value.trim();

                    // Remove any existing validation styling
                    e.target.style.borderColor = '';

                    if (name.length > 20) {
                        e.target.style.borderColor = 'red';
                        e.target.title = 'Name must be 20 characters or less';
                    } else if (name.length > 0 && !/^[a-zA-Z0-9\s_-]+$/.test(name)) {
                        e.target.style.borderColor = 'orange';
                        e.target.title = 'Only letters, numbers, spaces, underscore, and dash allowed';
                    } else if (name.length > 0) {
                        e.target.style.borderColor = 'green';
                        e.target.title = 'Valid username';
                    }
                });
            }
        });

        // Memory cleanup
        setInterval(() => {
            const gameMessages = document.getElementById('gameMessages');
            if (gameMessages && gameMessages.children.length > 100) {
                while (gameMessages.children.length > 50) {
                    gameMessages.removeChild(gameMessages.firstChild);
                }
            }

            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages && chatMessages.children.length > 50) {
                while (chatMessages.children.length > 25) {
                    chatMessages.removeChild(chatMessages.firstChild);
                }
            }
        }, 30000);
    </script>
</body>

</html>